var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import { PureComponent, createElement } from 'react';
import PropTypes from 'prop-types';

import StaticMap from './static-map';
import { MAPBOX_LIMITS } from '../utils/map-state';
import WebMercatorViewport from 'viewport-mercator-project';

import TransitionManager from '../utils/transition-manager';

import { EventManager } from 'mjolnir.js';
import MapControls from '../utils/map-controls';
import config from '../config';
import deprecateWarn from '../utils/deprecate-warn';

var propTypes = Object.assign({}, StaticMap.propTypes, {
  // Additional props on top of StaticMap

  /** Viewport constraints */
  // Max zoom level
  maxZoom: PropTypes.number,
  // Min zoom level
  minZoom: PropTypes.number,
  // Max pitch in degrees
  maxPitch: PropTypes.number,
  // Min pitch in degrees
  minPitch: PropTypes.number,

  /**
   * `onViewportChange` callback is fired when the user interacted with the
   * map. The object passed to the callback contains viewport properties
   * such as `longitude`, `latitude`, `zoom` etc.
   */
  onViewportChange: PropTypes.func,

  /** Viewport transition **/
  // transition duration for viewport change
  transitionDuration: PropTypes.number,
  // TransitionInterpolator instance, can be used to perform custom transitions.
  transitionInterpolator: PropTypes.object,
  // type of interruption of current transition on update.
  transitionInterruption: PropTypes.number,
  // easing function
  transitionEasing: PropTypes.func,
  // transition status update functions
  onTransitionStart: PropTypes.func,
  onTransitionInterrupt: PropTypes.func,
  onTransitionEnd: PropTypes.func,

  /** Enables control event handling */
  // Scroll to zoom
  scrollZoom: PropTypes.bool,
  // Drag to pan
  dragPan: PropTypes.bool,
  // Drag to rotate
  dragRotate: PropTypes.bool,
  // Double click to zoom
  doubleClickZoom: PropTypes.bool,
  // Multitouch zoom
  touchZoom: PropTypes.bool,
  // Multitouch rotate
  touchRotate: PropTypes.bool,
  // Keyboard
  keyboard: PropTypes.bool,

  /**
     * Called when the map is hovered over.
     * @callback
     * @param {Object} event - The mouse event.
     * @param {[Number, Number]} event.lngLat - The coordinates of the pointer
     * @param {Array} event.features - The features under the pointer, using Mapbox's
     * queryRenderedFeatures API:
     * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures
     * To make a layer interactive, set the `interactive` property in the
     * layer style to `true`. See Mapbox's style spec
     * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive
     */
  onHover: PropTypes.func,
  /**
    * Called when the map is clicked.
    * @callback
    * @param {Object} event - The mouse event.
    * @param {[Number, Number]} event.lngLat - The coordinates of the pointer
    * @param {Array} event.features - The features under the pointer, using Mapbox's
    * queryRenderedFeatures API:
    * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures
    * To make a layer interactive, set the `interactive` property in the
    * layer style to `true`. See Mapbox's style spec
    * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive
    */
  onClick: PropTypes.func,
  /**
    * Called when the context menu is activated.
    */
  onContextMenu: PropTypes.func,

  /** Custom touch-action CSS for the event canvas. Defaults to 'none' */
  touchAction: PropTypes.string,

  /** Radius to detect features around a clicked point. Defaults to 0. */
  clickRadius: PropTypes.number,

  /** Accessor that returns a cursor style to show interactive state */
  getCursor: PropTypes.func,

  /** Advanced features */
  // Contraints for displaying the map. If not met, then the map is hidden.
  // Experimental! May be changed in minor version updates.
  visibilityConstraints: PropTypes.shape({
    minZoom: PropTypes.number,
    maxZoom: PropTypes.number,
    minPitch: PropTypes.number,
    maxPitch: PropTypes.number
  }),
  // A map control instance to replace the default map controls
  // The object must expose one property: `events` as an array of subscribed
  // event names; and two methods: `setState(state)` and `handle(event)`
  mapControls: PropTypes.shape({
    events: PropTypes.arrayOf(PropTypes.string),
    handleEvent: PropTypes.func
  })
});

var getDefaultCursor = function getDefaultCursor(_ref) {
  var isDragging = _ref.isDragging,
      isHovering = _ref.isHovering;
  return isDragging ? config.CURSOR.GRABBING : isHovering ? config.CURSOR.POINTER : config.CURSOR.GRAB;
};

var defaultProps = Object.assign({}, StaticMap.defaultProps, MAPBOX_LIMITS, TransitionManager.defaultProps, {
  onViewportChange: null,
  onClick: null,
  onHover: null,
  onContextMenu: function onContextMenu(event) {
    return event.preventDefault();
  },

  scrollZoom: true,
  dragPan: true,
  dragRotate: true,
  doubleClickZoom: true,

  touchAction: 'none',
  clickRadius: 0,
  getCursor: getDefaultCursor,

  visibilityConstraints: MAPBOX_LIMITS
});

var childContextTypes = {
  viewport: PropTypes.instanceOf(WebMercatorViewport),
  isDragging: PropTypes.bool,
  eventManager: PropTypes.object
};

var InteractiveMap = function (_PureComponent) {
  _inherits(InteractiveMap, _PureComponent);

  _createClass(InteractiveMap, null, [{
    key: 'supported',
    value: function supported() {
      return StaticMap.supported();
    }
  }]);

  function InteractiveMap(props) {
    _classCallCheck(this, InteractiveMap);

    // Check for deprecated props
    var _this = _possibleConstructorReturn(this, (InteractiveMap.__proto__ || Object.getPrototypeOf(InteractiveMap)).call(this, props));

    deprecateWarn(props);

    _this.state = {
      // Whether the cursor is down
      isDragging: false,
      // Whether the cursor is over a clickable feature
      isHovering: false
    };

    // If props.mapControls is not provided, fallback to default MapControls instance
    // Cannot use defaultProps here because it needs to be per map instance
    _this._mapControls = props.mapControls || new MapControls();

    _this._eventManager = new EventManager(null, {
      legacyBlockScroll: false,
      touchAction: props.touchAction
    });

    _this.getMap = _this.getMap.bind(_this);
    _this.queryRenderedFeatures = _this.queryRenderedFeatures.bind(_this);
    _this._checkVisibilityConstraints = _this._checkVisibilityConstraints.bind(_this);
    _this._getFeatures = _this._getFeatures.bind(_this);
    _this._onInteractiveStateChange = _this._onInteractiveStateChange.bind(_this);
    _this._getPos = _this._getPos.bind(_this);
    _this._eventCanvasLoaded = _this._eventCanvasLoaded.bind(_this);
    _this._staticMapLoaded = _this._staticMapLoaded.bind(_this);
    return _this;
  }

  _createClass(InteractiveMap, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        viewport: new WebMercatorViewport(this.props),
        isDragging: this.state.isDragging,
        eventManager: this._eventManager
      };
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var eventManager = this._eventManager;

      // Register additional event handlers for click and hover
      eventManager.on({
        mousemove: this._onMouseMove.bind(this),
        click: this._onMouseClick.bind(this),
        contextmenu: this._onContextMenu.bind(this)
      });

      this._mapControls.setOptions(Object.assign({}, this.props, {
        onStateChange: this._onInteractiveStateChange,
        eventManager: eventManager
      }));

      this._transitionManager = new TransitionManager(this.props);
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      this._mapControls.setOptions(nextProps);
      this._transitionManager.processViewportChange(nextProps);
    }
  }, {
    key: 'getMap',
    value: function getMap() {
      return this._map ? this._map.getMap() : null;
    }
  }, {
    key: 'queryRenderedFeatures',
    value: function queryRenderedFeatures(geometry, options) {
      return this._map.queryRenderedFeatures(geometry, options);
    }

    // Checks a visibilityConstraints object to see if the map should be displayed

  }, {
    key: '_checkVisibilityConstraints',
    value: function _checkVisibilityConstraints(props) {
      var capitalize = function capitalize(s) {
        return s[0].toUpperCase() + s.slice(1);
      };

      var visibilityConstraints = props.visibilityConstraints;

      for (var propName in props) {
        var capitalizedPropName = capitalize(propName);
        var minPropName = 'min' + capitalizedPropName;
        var maxPropName = 'max' + capitalizedPropName;

        if (minPropName in visibilityConstraints && props[propName] < visibilityConstraints[minPropName]) {
          return false;
        }
        if (maxPropName in visibilityConstraints && props[propName] > visibilityConstraints[maxPropName]) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: '_getFeatures',
    value: function _getFeatures(_ref2) {
      var pos = _ref2.pos,
          radius = _ref2.radius;

      var features = void 0;
      if (radius) {
        // Radius enables point features, like marker symbols, to be clicked.
        var size = radius;
        var bbox = [[pos[0] - size, pos[1] + size], [pos[0] + size, pos[1] - size]];
        features = this._map.queryRenderedFeatures(bbox);
      } else {
        features = this._map.queryRenderedFeatures(pos);
      }
      return features;
    }
  }, {
    key: '_onInteractiveStateChange',
    value: function _onInteractiveStateChange(_ref3) {
      var _ref3$isDragging = _ref3.isDragging,
          isDragging = _ref3$isDragging === undefined ? false : _ref3$isDragging;

      if (isDragging !== this.state.isDragging) {
        this.setState({ isDragging: isDragging });
      }
    }

    // HOVER AND CLICK

  }, {
    key: '_getPos',
    value: function _getPos(event) {
      var _event$offsetCenter = event.offsetCenter,
          x = _event$offsetCenter.x,
          y = _event$offsetCenter.y;

      return [x, y];
    }
  }, {
    key: '_onMouseMove',
    value: function _onMouseMove(event) {
      if (!this.state.isDragging) {
        var pos = this._getPos(event);
        var features = this._getFeatures({ pos: pos, radius: this.props.clickRadius });

        var isHovering = features && features.length > 0;
        if (isHovering !== this.state.isHovering) {
          this.setState({ isHovering: isHovering });
        }

        if (this.props.onHover) {
          var viewport = new WebMercatorViewport(this.props);
          event.lngLat = viewport.unproject(pos);
          event.features = features;

          this.props.onHover(event);
        }
      }
    }
  }, {
    key: '_onMouseClick',
    value: function _onMouseClick(event) {
      if (this.props.onClick) {
        var pos = this._getPos(event);
        var viewport = new WebMercatorViewport(this.props);
        event.lngLat = viewport.unproject(pos);
        event.features = this._getFeatures({ pos: pos, radius: this.props.clickRadius });

        this.props.onClick(event);
      }
    }
  }, {
    key: '_onContextMenu',
    value: function _onContextMenu(event) {
      if (this.props.onContextMenu) {
        this.props.onContextMenu(event);
      }
    }
  }, {
    key: '_eventCanvasLoaded',
    value: function _eventCanvasLoaded(ref) {
      // This will be called with `null` after unmount, releasing event manager resource
      this._eventManager.setElement(ref);
    }
  }, {
    key: '_staticMapLoaded',
    value: function _staticMapLoaded(ref) {
      this._map = ref;
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          height = _props.height,
          getCursor = _props.getCursor;


      var eventCanvasStyle = {
        width: width,
        height: height,
        position: 'relative',
        cursor: getCursor(this.state)
      };

      return createElement('div', {
        key: 'map-controls',
        ref: this._eventCanvasLoaded,
        style: eventCanvasStyle
      }, createElement(StaticMap, Object.assign({}, this.props, this._transitionManager && this._transitionManager.getViewportInTransition(), {
        visible: this._checkVisibilityConstraints(this.props),
        ref: this._staticMapLoaded,
        children: this.props.children
      })));
    }
  }]);

  return InteractiveMap;
}(PureComponent);

export default InteractiveMap;


InteractiveMap.displayName = 'InteractiveMap';
InteractiveMap.propTypes = propTypes;
InteractiveMap.defaultProps = defaultProps;
InteractiveMap.childContextTypes = childContextTypes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL2ludGVyYWN0aXZlLW1hcC5qcyJdLCJuYW1lcyI6WyJQdXJlQ29tcG9uZW50IiwiY3JlYXRlRWxlbWVudCIsIlByb3BUeXBlcyIsIlN0YXRpY01hcCIsIk1BUEJPWF9MSU1JVFMiLCJXZWJNZXJjYXRvclZpZXdwb3J0IiwiVHJhbnNpdGlvbk1hbmFnZXIiLCJFdmVudE1hbmFnZXIiLCJNYXBDb250cm9scyIsImNvbmZpZyIsImRlcHJlY2F0ZVdhcm4iLCJwcm9wVHlwZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJtYXhab29tIiwibnVtYmVyIiwibWluWm9vbSIsIm1heFBpdGNoIiwibWluUGl0Y2giLCJvblZpZXdwb3J0Q2hhbmdlIiwiZnVuYyIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25JbnRlcnBvbGF0b3IiLCJvYmplY3QiLCJ0cmFuc2l0aW9uSW50ZXJydXB0aW9uIiwidHJhbnNpdGlvbkVhc2luZyIsIm9uVHJhbnNpdGlvblN0YXJ0Iiwib25UcmFuc2l0aW9uSW50ZXJydXB0Iiwib25UcmFuc2l0aW9uRW5kIiwic2Nyb2xsWm9vbSIsImJvb2wiLCJkcmFnUGFuIiwiZHJhZ1JvdGF0ZSIsImRvdWJsZUNsaWNrWm9vbSIsInRvdWNoWm9vbSIsInRvdWNoUm90YXRlIiwia2V5Ym9hcmQiLCJvbkhvdmVyIiwib25DbGljayIsIm9uQ29udGV4dE1lbnUiLCJ0b3VjaEFjdGlvbiIsInN0cmluZyIsImNsaWNrUmFkaXVzIiwiZ2V0Q3Vyc29yIiwidmlzaWJpbGl0eUNvbnN0cmFpbnRzIiwic2hhcGUiLCJtYXBDb250cm9scyIsImV2ZW50cyIsImFycmF5T2YiLCJoYW5kbGVFdmVudCIsImdldERlZmF1bHRDdXJzb3IiLCJpc0RyYWdnaW5nIiwiaXNIb3ZlcmluZyIsIkNVUlNPUiIsIkdSQUJCSU5HIiwiUE9JTlRFUiIsIkdSQUIiLCJkZWZhdWx0UHJvcHMiLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwiY2hpbGRDb250ZXh0VHlwZXMiLCJ2aWV3cG9ydCIsImluc3RhbmNlT2YiLCJldmVudE1hbmFnZXIiLCJJbnRlcmFjdGl2ZU1hcCIsInN1cHBvcnRlZCIsInByb3BzIiwic3RhdGUiLCJfbWFwQ29udHJvbHMiLCJfZXZlbnRNYW5hZ2VyIiwibGVnYWN5QmxvY2tTY3JvbGwiLCJnZXRNYXAiLCJiaW5kIiwicXVlcnlSZW5kZXJlZEZlYXR1cmVzIiwiX2NoZWNrVmlzaWJpbGl0eUNvbnN0cmFpbnRzIiwiX2dldEZlYXR1cmVzIiwiX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZSIsIl9nZXRQb3MiLCJfZXZlbnRDYW52YXNMb2FkZWQiLCJfc3RhdGljTWFwTG9hZGVkIiwib24iLCJtb3VzZW1vdmUiLCJfb25Nb3VzZU1vdmUiLCJjbGljayIsIl9vbk1vdXNlQ2xpY2siLCJjb250ZXh0bWVudSIsIl9vbkNvbnRleHRNZW51Iiwic2V0T3B0aW9ucyIsIm9uU3RhdGVDaGFuZ2UiLCJfdHJhbnNpdGlvbk1hbmFnZXIiLCJuZXh0UHJvcHMiLCJwcm9jZXNzVmlld3BvcnRDaGFuZ2UiLCJfbWFwIiwiZ2VvbWV0cnkiLCJvcHRpb25zIiwiY2FwaXRhbGl6ZSIsInMiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwicHJvcE5hbWUiLCJjYXBpdGFsaXplZFByb3BOYW1lIiwibWluUHJvcE5hbWUiLCJtYXhQcm9wTmFtZSIsInBvcyIsInJhZGl1cyIsImZlYXR1cmVzIiwic2l6ZSIsImJib3giLCJzZXRTdGF0ZSIsIm9mZnNldENlbnRlciIsIngiLCJ5IiwibGVuZ3RoIiwibG5nTGF0IiwidW5wcm9qZWN0IiwicmVmIiwic2V0RWxlbWVudCIsIndpZHRoIiwiaGVpZ2h0IiwiZXZlbnRDYW52YXNTdHlsZSIsInBvc2l0aW9uIiwiY3Vyc29yIiwia2V5Iiwic3R5bGUiLCJnZXRWaWV3cG9ydEluVHJhbnNpdGlvbiIsInZpc2libGUiLCJjaGlsZHJlbiIsImRpc3BsYXlOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLFNBQVFB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ZSI6ImludGVyYWN0aXZlLW1hcC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UHVyZUNvbXBvbmVudCwgY3JlYXRlRWxlbWVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IFN0YXRpY01hcCBmcm9tICcuL3N0YXRpYy1tYXAnO1xuaW1wb3J0IHtNQVBCT1hfTElNSVRTfSBmcm9tICcuLi91dGlscy9tYXAtc3RhdGUnO1xuaW1wb3J0IFdlYk1lcmNhdG9yVmlld3BvcnQgZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5cbmltcG9ydCBUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuLi91dGlscy90cmFuc2l0aW9uLW1hbmFnZXInO1xuXG5pbXBvcnQge0V2ZW50TWFuYWdlcn0gZnJvbSAnbWpvbG5pci5qcyc7XG5pbXBvcnQgTWFwQ29udHJvbHMgZnJvbSAnLi4vdXRpbHMvbWFwLWNvbnRyb2xzJztcbmltcG9ydCBjb25maWcgZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCBkZXByZWNhdGVXYXJuIGZyb20gJy4uL3V0aWxzL2RlcHJlY2F0ZS13YXJuJztcblxuY29uc3QgcHJvcFR5cGVzID0gT2JqZWN0LmFzc2lnbih7fSwgU3RhdGljTWFwLnByb3BUeXBlcywge1xuICAvLyBBZGRpdGlvbmFsIHByb3BzIG9uIHRvcCBvZiBTdGF0aWNNYXBcblxuICAvKiogVmlld3BvcnQgY29uc3RyYWludHMgKi9cbiAgLy8gTWF4IHpvb20gbGV2ZWxcbiAgbWF4Wm9vbTogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gTWluIHpvb20gbGV2ZWxcbiAgbWluWm9vbTogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gTWF4IHBpdGNoIGluIGRlZ3JlZXNcbiAgbWF4UGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIE1pbiBwaXRjaCBpbiBkZWdyZWVzXG4gIG1pblBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBgb25WaWV3cG9ydENoYW5nZWAgY2FsbGJhY2sgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlXG4gICAqIG1hcC4gVGhlIG9iamVjdCBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGNvbnRhaW5zIHZpZXdwb3J0IHByb3BlcnRpZXNcbiAgICogc3VjaCBhcyBgbG9uZ2l0dWRlYCwgYGxhdGl0dWRlYCwgYHpvb21gIGV0Yy5cbiAgICovXG4gIG9uVmlld3BvcnRDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKiBWaWV3cG9ydCB0cmFuc2l0aW9uICoqL1xuICAvLyB0cmFuc2l0aW9uIGR1cmF0aW9uIGZvciB2aWV3cG9ydCBjaGFuZ2VcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBUcmFuc2l0aW9uSW50ZXJwb2xhdG9yIGluc3RhbmNlLCBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGN1c3RvbSB0cmFuc2l0aW9ucy5cbiAgdHJhbnNpdGlvbkludGVycG9sYXRvcjogUHJvcFR5cGVzLm9iamVjdCxcbiAgLy8gdHlwZSBvZiBpbnRlcnJ1cHRpb24gb2YgY3VycmVudCB0cmFuc2l0aW9uIG9uIHVwZGF0ZS5cbiAgdHJhbnNpdGlvbkludGVycnVwdGlvbjogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gZWFzaW5nIGZ1bmN0aW9uXG4gIHRyYW5zaXRpb25FYXNpbmc6IFByb3BUeXBlcy5mdW5jLFxuICAvLyB0cmFuc2l0aW9uIHN0YXR1cyB1cGRhdGUgZnVuY3Rpb25zXG4gIG9uVHJhbnNpdGlvblN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25UcmFuc2l0aW9uSW50ZXJydXB0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25UcmFuc2l0aW9uRW5kOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKiogRW5hYmxlcyBjb250cm9sIGV2ZW50IGhhbmRsaW5nICovXG4gIC8vIFNjcm9sbCB0byB6b29tXG4gIHNjcm9sbFpvb206IFByb3BUeXBlcy5ib29sLFxuICAvLyBEcmFnIHRvIHBhblxuICBkcmFnUGFuOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gRHJhZyB0byByb3RhdGVcbiAgZHJhZ1JvdGF0ZTogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIERvdWJsZSBjbGljayB0byB6b29tXG4gIGRvdWJsZUNsaWNrWm9vbTogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIE11bHRpdG91Y2ggem9vbVxuICB0b3VjaFpvb206IFByb3BUeXBlcy5ib29sLFxuICAvLyBNdWx0aXRvdWNoIHJvdGF0ZVxuICB0b3VjaFJvdGF0ZTogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIEtleWJvYXJkXG4gIGtleWJvYXJkOiBQcm9wVHlwZXMuYm9vbCxcblxuIC8qKlxuICAgICogQ2FsbGVkIHdoZW4gdGhlIG1hcCBpcyBob3ZlcmVkIG92ZXIuXG4gICAgKiBAY2FsbGJhY2tcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBtb3VzZSBldmVudC5cbiAgICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gZXZlbnQubG5nTGF0IC0gVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludGVyXG4gICAgKiBAcGFyYW0ge0FycmF5fSBldmVudC5mZWF0dXJlcyAtIFRoZSBmZWF0dXJlcyB1bmRlciB0aGUgcG9pbnRlciwgdXNpbmcgTWFwYm94J3NcbiAgICAqIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyBBUEk6XG4gICAgKiBodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9hcGkvI01hcCNxdWVyeVJlbmRlcmVkRmVhdHVyZXNcbiAgICAqIFRvIG1ha2UgYSBsYXllciBpbnRlcmFjdGl2ZSwgc2V0IHRoZSBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IGluIHRoZVxuICAgICogbGF5ZXIgc3R5bGUgdG8gYHRydWVgLiBTZWUgTWFwYm94J3Mgc3R5bGUgc3BlY1xuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jbGF5ZXItaW50ZXJhY3RpdmVcbiAgICAqL1xuICBvbkhvdmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAgKiBDYWxsZWQgd2hlbiB0aGUgbWFwIGlzIGNsaWNrZWQuXG4gICAgKiBAY2FsbGJhY2tcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBtb3VzZSBldmVudC5cbiAgICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gZXZlbnQubG5nTGF0IC0gVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludGVyXG4gICAgKiBAcGFyYW0ge0FycmF5fSBldmVudC5mZWF0dXJlcyAtIFRoZSBmZWF0dXJlcyB1bmRlciB0aGUgcG9pbnRlciwgdXNpbmcgTWFwYm94J3NcbiAgICAqIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyBBUEk6XG4gICAgKiBodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9hcGkvI01hcCNxdWVyeVJlbmRlcmVkRmVhdHVyZXNcbiAgICAqIFRvIG1ha2UgYSBsYXllciBpbnRlcmFjdGl2ZSwgc2V0IHRoZSBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IGluIHRoZVxuICAgICogbGF5ZXIgc3R5bGUgdG8gYHRydWVgLiBTZWUgTWFwYm94J3Mgc3R5bGUgc3BlY1xuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jbGF5ZXItaW50ZXJhY3RpdmVcbiAgICAqL1xuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAgKiBDYWxsZWQgd2hlbiB0aGUgY29udGV4dCBtZW51IGlzIGFjdGl2YXRlZC5cbiAgICAqL1xuICBvbkNvbnRleHRNZW51OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKiogQ3VzdG9tIHRvdWNoLWFjdGlvbiBDU1MgZm9yIHRoZSBldmVudCBjYW52YXMuIERlZmF1bHRzIHRvICdub25lJyAqL1xuICB0b3VjaEFjdGlvbjogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKiogUmFkaXVzIHRvIGRldGVjdCBmZWF0dXJlcyBhcm91bmQgYSBjbGlja2VkIHBvaW50LiBEZWZhdWx0cyB0byAwLiAqL1xuICBjbGlja1JhZGl1czogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKiogQWNjZXNzb3IgdGhhdCByZXR1cm5zIGEgY3Vyc29yIHN0eWxlIHRvIHNob3cgaW50ZXJhY3RpdmUgc3RhdGUgKi9cbiAgZ2V0Q3Vyc29yOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKiogQWR2YW5jZWQgZmVhdHVyZXMgKi9cbiAgLy8gQ29udHJhaW50cyBmb3IgZGlzcGxheWluZyB0aGUgbWFwLiBJZiBub3QgbWV0LCB0aGVuIHRoZSBtYXAgaXMgaGlkZGVuLlxuICAvLyBFeHBlcmltZW50YWwhIE1heSBiZSBjaGFuZ2VkIGluIG1pbm9yIHZlcnNpb24gdXBkYXRlcy5cbiAgdmlzaWJpbGl0eUNvbnN0cmFpbnRzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIG1pblpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gICAgbWF4Wm9vbTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBtaW5QaXRjaDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBtYXhQaXRjaDogUHJvcFR5cGVzLm51bWJlclxuICB9KSxcbiAgLy8gQSBtYXAgY29udHJvbCBpbnN0YW5jZSB0byByZXBsYWNlIHRoZSBkZWZhdWx0IG1hcCBjb250cm9sc1xuICAvLyBUaGUgb2JqZWN0IG11c3QgZXhwb3NlIG9uZSBwcm9wZXJ0eTogYGV2ZW50c2AgYXMgYW4gYXJyYXkgb2Ygc3Vic2NyaWJlZFxuICAvLyBldmVudCBuYW1lczsgYW5kIHR3byBtZXRob2RzOiBgc2V0U3RhdGUoc3RhdGUpYCBhbmQgYGhhbmRsZShldmVudClgXG4gIG1hcENvbnRyb2xzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGV2ZW50czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gICAgaGFuZGxlRXZlbnQ6IFByb3BUeXBlcy5mdW5jXG4gIH0pXG59KTtcblxuY29uc3QgZ2V0RGVmYXVsdEN1cnNvciA9ICh7aXNEcmFnZ2luZywgaXNIb3ZlcmluZ30pID0+IGlzRHJhZ2dpbmcgP1xuICBjb25maWcuQ1VSU09SLkdSQUJCSU5HIDpcbiAgKGlzSG92ZXJpbmcgPyBjb25maWcuQ1VSU09SLlBPSU5URVIgOiBjb25maWcuQ1VSU09SLkdSQUIpO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LFxuICBTdGF0aWNNYXAuZGVmYXVsdFByb3BzLCBNQVBCT1hfTElNSVRTLCBUcmFuc2l0aW9uTWFuYWdlci5kZWZhdWx0UHJvcHMsXG4gIHtcbiAgICBvblZpZXdwb3J0Q2hhbmdlOiBudWxsLFxuICAgIG9uQ2xpY2s6IG51bGwsXG4gICAgb25Ib3ZlcjogbnVsbCxcbiAgICBvbkNvbnRleHRNZW51OiBldmVudCA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpLFxuXG4gICAgc2Nyb2xsWm9vbTogdHJ1ZSxcbiAgICBkcmFnUGFuOiB0cnVlLFxuICAgIGRyYWdSb3RhdGU6IHRydWUsXG4gICAgZG91YmxlQ2xpY2tab29tOiB0cnVlLFxuXG4gICAgdG91Y2hBY3Rpb246ICdub25lJyxcbiAgICBjbGlja1JhZGl1czogMCxcbiAgICBnZXRDdXJzb3I6IGdldERlZmF1bHRDdXJzb3IsXG5cbiAgICB2aXNpYmlsaXR5Q29uc3RyYWludHM6IE1BUEJPWF9MSU1JVFNcbiAgfVxuKTtcblxuY29uc3QgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHZpZXdwb3J0OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihXZWJNZXJjYXRvclZpZXdwb3J0KSxcbiAgaXNEcmFnZ2luZzogUHJvcFR5cGVzLmJvb2wsXG4gIGV2ZW50TWFuYWdlcjogUHJvcFR5cGVzLm9iamVjdFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50ZXJhY3RpdmVNYXAgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcblxuICBzdGF0aWMgc3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBTdGF0aWNNYXAuc3VwcG9ydGVkKCk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICAvLyBDaGVjayBmb3IgZGVwcmVjYXRlZCBwcm9wc1xuICAgIGRlcHJlY2F0ZVdhcm4ocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC8vIFdoZXRoZXIgdGhlIGN1cnNvciBpcyBkb3duXG4gICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgIC8vIFdoZXRoZXIgdGhlIGN1cnNvciBpcyBvdmVyIGEgY2xpY2thYmxlIGZlYXR1cmVcbiAgICAgIGlzSG92ZXJpbmc6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIElmIHByb3BzLm1hcENvbnRyb2xzIGlzIG5vdCBwcm92aWRlZCwgZmFsbGJhY2sgdG8gZGVmYXVsdCBNYXBDb250cm9scyBpbnN0YW5jZVxuICAgIC8vIENhbm5vdCB1c2UgZGVmYXVsdFByb3BzIGhlcmUgYmVjYXVzZSBpdCBuZWVkcyB0byBiZSBwZXIgbWFwIGluc3RhbmNlXG4gICAgdGhpcy5fbWFwQ29udHJvbHMgPSBwcm9wcy5tYXBDb250cm9scyB8fCBuZXcgTWFwQ29udHJvbHMoKTtcblxuICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIobnVsbCwge1xuICAgICAgbGVnYWN5QmxvY2tTY3JvbGw6IGZhbHNlLFxuICAgICAgdG91Y2hBY3Rpb246IHByb3BzLnRvdWNoQWN0aW9uXG4gICAgfSk7XG5cbiAgICB0aGlzLmdldE1hcCA9IHRoaXMuZ2V0TWFwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5xdWVyeVJlbmRlcmVkRmVhdHVyZXMgPSB0aGlzLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NoZWNrVmlzaWJpbGl0eUNvbnN0cmFpbnRzID0gdGhpcy5fY2hlY2tWaXNpYmlsaXR5Q29uc3RyYWludHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9nZXRGZWF0dXJlcyA9IHRoaXMuX2dldEZlYXR1cmVzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlID0gdGhpcy5fb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fZ2V0UG9zID0gdGhpcy5fZ2V0UG9zLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fZXZlbnRDYW52YXNMb2FkZWQgPSB0aGlzLl9ldmVudENhbnZhc0xvYWRlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3N0YXRpY01hcExvYWRlZCA9IHRoaXMuX3N0YXRpY01hcExvYWRlZC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2aWV3cG9ydDogbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodGhpcy5wcm9wcyksXG4gICAgICBpc0RyYWdnaW5nOiB0aGlzLnN0YXRlLmlzRHJhZ2dpbmcsXG4gICAgICBldmVudE1hbmFnZXI6IHRoaXMuX2V2ZW50TWFuYWdlclxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCBldmVudE1hbmFnZXIgPSB0aGlzLl9ldmVudE1hbmFnZXI7XG5cbiAgICAvLyBSZWdpc3RlciBhZGRpdGlvbmFsIGV2ZW50IGhhbmRsZXJzIGZvciBjbGljayBhbmQgaG92ZXJcbiAgICBldmVudE1hbmFnZXIub24oe1xuICAgICAgbW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZS5iaW5kKHRoaXMpLFxuICAgICAgY2xpY2s6IHRoaXMuX29uTW91c2VDbGljay5iaW5kKHRoaXMpLFxuICAgICAgY29udGV4dG1lbnU6IHRoaXMuX29uQ29udGV4dE1lbnUuYmluZCh0aGlzKVxuICAgIH0pO1xuXG4gICAgdGhpcy5fbWFwQ29udHJvbHMuc2V0T3B0aW9ucyhPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICBvblN0YXRlQ2hhbmdlOiB0aGlzLl9vbkludGVyYWN0aXZlU3RhdGVDaGFuZ2UsXG4gICAgICBldmVudE1hbmFnZXJcbiAgICB9KSk7XG5cbiAgICB0aGlzLl90cmFuc2l0aW9uTWFuYWdlciA9IG5ldyBUcmFuc2l0aW9uTWFuYWdlcih0aGlzLnByb3BzKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgdGhpcy5fbWFwQ29udHJvbHMuc2V0T3B0aW9ucyhuZXh0UHJvcHMpO1xuICAgIHRoaXMuX3RyYW5zaXRpb25NYW5hZ2VyLnByb2Nlc3NWaWV3cG9ydENoYW5nZShuZXh0UHJvcHMpO1xuICB9XG5cbiAgZ2V0TWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAgPyB0aGlzLl9tYXAuZ2V0TWFwKCkgOiBudWxsO1xuICB9XG5cbiAgcXVlcnlSZW5kZXJlZEZlYXR1cmVzKGdlb21ldHJ5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoZ2VvbWV0cnksIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gQ2hlY2tzIGEgdmlzaWJpbGl0eUNvbnN0cmFpbnRzIG9iamVjdCB0byBzZWUgaWYgdGhlIG1hcCBzaG91bGQgYmUgZGlzcGxheWVkXG4gIF9jaGVja1Zpc2liaWxpdHlDb25zdHJhaW50cyhwcm9wcykge1xuICAgIGNvbnN0IGNhcGl0YWxpemUgPSBzID0+IHNbMF0udG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7XG5cbiAgICBjb25zdCB7dmlzaWJpbGl0eUNvbnN0cmFpbnRzfSA9IHByb3BzO1xuICAgIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgIGNvbnN0IGNhcGl0YWxpemVkUHJvcE5hbWUgPSBjYXBpdGFsaXplKHByb3BOYW1lKTtcbiAgICAgIGNvbnN0IG1pblByb3BOYW1lID0gYG1pbiR7Y2FwaXRhbGl6ZWRQcm9wTmFtZX1gO1xuICAgICAgY29uc3QgbWF4UHJvcE5hbWUgPSBgbWF4JHtjYXBpdGFsaXplZFByb3BOYW1lfWA7XG5cbiAgICAgIGlmIChtaW5Qcm9wTmFtZSBpbiB2aXNpYmlsaXR5Q29uc3RyYWludHMgJiZcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdIDwgdmlzaWJpbGl0eUNvbnN0cmFpbnRzW21pblByb3BOYW1lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobWF4UHJvcE5hbWUgaW4gdmlzaWJpbGl0eUNvbnN0cmFpbnRzICYmXG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA+IHZpc2liaWxpdHlDb25zdHJhaW50c1ttYXhQcm9wTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9nZXRGZWF0dXJlcyh7cG9zLCByYWRpdXN9KSB7XG4gICAgbGV0IGZlYXR1cmVzO1xuICAgIGlmIChyYWRpdXMpIHtcbiAgICAgIC8vIFJhZGl1cyBlbmFibGVzIHBvaW50IGZlYXR1cmVzLCBsaWtlIG1hcmtlciBzeW1ib2xzLCB0byBiZSBjbGlja2VkLlxuICAgICAgY29uc3Qgc2l6ZSA9IHJhZGl1cztcbiAgICAgIGNvbnN0IGJib3ggPSBbW3Bvc1swXSAtIHNpemUsIHBvc1sxXSArIHNpemVdLCBbcG9zWzBdICsgc2l6ZSwgcG9zWzFdIC0gc2l6ZV1dO1xuICAgICAgZmVhdHVyZXMgPSB0aGlzLl9tYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGJib3gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmZWF0dXJlcyA9IHRoaXMuX21hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMocG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZSh7aXNEcmFnZ2luZyA9IGZhbHNlfSkge1xuICAgIGlmIChpc0RyYWdnaW5nICE9PSB0aGlzLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2lzRHJhZ2dpbmd9KTtcbiAgICB9XG4gIH1cblxuICAvLyBIT1ZFUiBBTkQgQ0xJQ0tcbiAgX2dldFBvcyhldmVudCkge1xuICAgIGNvbnN0IHtvZmZzZXRDZW50ZXI6IHt4LCB5fX0gPSBldmVudDtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9XG5cbiAgX29uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX2dldFBvcyhldmVudCk7XG4gICAgICBjb25zdCBmZWF0dXJlcyA9IHRoaXMuX2dldEZlYXR1cmVzKHtwb3MsIHJhZGl1czogdGhpcy5wcm9wcy5jbGlja1JhZGl1c30pO1xuXG4gICAgICBjb25zdCBpc0hvdmVyaW5nID0gZmVhdHVyZXMgJiYgZmVhdHVyZXMubGVuZ3RoID4gMDtcbiAgICAgIGlmIChpc0hvdmVyaW5nICE9PSB0aGlzLnN0YXRlLmlzSG92ZXJpbmcpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNIb3ZlcmluZ30pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcm9wcy5vbkhvdmVyKSB7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodGhpcy5wcm9wcyk7XG4gICAgICAgIGV2ZW50LmxuZ0xhdCA9IHZpZXdwb3J0LnVucHJvamVjdChwb3MpO1xuICAgICAgICBldmVudC5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25Ib3ZlcihldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX29uTW91c2VDbGljayhldmVudCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2spIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX2dldFBvcyhldmVudCk7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHRoaXMucHJvcHMpO1xuICAgICAgZXZlbnQubG5nTGF0ID0gdmlld3BvcnQudW5wcm9qZWN0KHBvcyk7XG4gICAgICBldmVudC5mZWF0dXJlcyA9IHRoaXMuX2dldEZlYXR1cmVzKHtwb3MsIHJhZGl1czogdGhpcy5wcm9wcy5jbGlja1JhZGl1c30pO1xuXG4gICAgICB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkNvbnRleHRNZW51KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25Db250ZXh0TWVudSkge1xuICAgICAgdGhpcy5wcm9wcy5vbkNvbnRleHRNZW51KGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBfZXZlbnRDYW52YXNMb2FkZWQocmVmKSB7XG4gICAgLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCB3aXRoIGBudWxsYCBhZnRlciB1bm1vdW50LCByZWxlYXNpbmcgZXZlbnQgbWFuYWdlciByZXNvdXJjZVxuICAgIHRoaXMuX2V2ZW50TWFuYWdlci5zZXRFbGVtZW50KHJlZik7XG4gIH1cblxuICBfc3RhdGljTWFwTG9hZGVkKHJlZikge1xuICAgIHRoaXMuX21hcCA9IHJlZjtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodCwgZ2V0Q3Vyc29yfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBldmVudENhbnZhc1N0eWxlID0ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIGN1cnNvcjogZ2V0Q3Vyc29yKHRoaXMuc3RhdGUpXG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIGtleTogJ21hcC1jb250cm9scycsXG4gICAgICAgIHJlZjogdGhpcy5fZXZlbnRDYW52YXNMb2FkZWQsXG4gICAgICAgIHN0eWxlOiBldmVudENhbnZhc1N0eWxlXG4gICAgICB9LFxuICAgICAgICBjcmVhdGVFbGVtZW50KFN0YXRpY01hcCwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcyxcbiAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uTWFuYWdlciAmJiB0aGlzLl90cmFuc2l0aW9uTWFuYWdlci5nZXRWaWV3cG9ydEluVHJhbnNpdGlvbigpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZpc2libGU6IHRoaXMuX2NoZWNrVmlzaWJpbGl0eUNvbnN0cmFpbnRzKHRoaXMucHJvcHMpLFxuICAgICAgICAgICAgcmVmOiB0aGlzLl9zdGF0aWNNYXBMb2FkZWQsXG4gICAgICAgICAgICBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgICAgIH1cbiAgICAgICAgKSlcbiAgICAgIClcbiAgICApO1xuICB9XG59XG5cbkludGVyYWN0aXZlTWFwLmRpc3BsYXlOYW1lID0gJ0ludGVyYWN0aXZlTWFwJztcbkludGVyYWN0aXZlTWFwLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbkludGVyYWN0aXZlTWFwLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbkludGVyYWN0aXZlTWFwLmNoaWxkQ29udGV4dFR5cGVzID0gY2hpbGRDb250ZXh0VHlwZXM7XG4iXX0=
import isImmutableMap from './is-immutable-map';
import diffStyles from './diff-styles';

export function getInteractiveLayerIds(mapStyle) {
  var interactiveLayerIds = null;

  if (isImmutableMap(mapStyle) && mapStyle.has('layers')) {
    interactiveLayerIds = mapStyle.get('layers').filter(function (l) {
      return l.get('interactive');
    }).map(function (l) {
      return l.get('id');
    }).toJS();
  } else if (Array.isArray(mapStyle.layers)) {
    interactiveLayerIds = mapStyle.layers.filter(function (l) {
      return l.interactive;
    }).map(function (l) {
      return l.id;
    });
  }

  return interactiveLayerIds;
}

// Individually update the maps source and layers that have changed if all
// other style props haven't changed. This prevents flicking of the map when
// styles only change sources or layers.
/* eslint-disable max-statements, complexity */
export function setDiffStyle(prevStyle, nextStyle, map) {
  var prevKeysMap = prevStyle && styleKeysMap(prevStyle) || {};
  var nextKeysMap = styleKeysMap(nextStyle);
  function styleKeysMap(style) {
    return style.map(function () {
      return true;
    }).delete('layers').delete('sources').toJS();
  }
  function propsOtherThanLayersOrSourcesDiffer() {
    var prevKeysList = Object.keys(prevKeysMap);
    var nextKeysList = Object.keys(nextKeysMap);
    if (prevKeysList.length !== nextKeysList.length) {
      return true;
    }
    // `nextStyle` and `prevStyle` should not have the same set of props.
    if (nextKeysList.some(function (key) {
      return prevStyle.get(key) !== nextStyle.get(key);
    }
    // But the value of one of those props is different.
    )) {
      return true;
    }
    return false;
  }

  if (!prevStyle || propsOtherThanLayersOrSourcesDiffer()) {
    map.setStyle(nextStyle.toJS());
    return;
  }

  var _diffStyles = diffStyles(prevStyle, nextStyle),
      sourcesDiff = _diffStyles.sourcesDiff,
      layersDiff = _diffStyles.layersDiff;

  checkForEqualLayerSourceChanges(sourcesDiff.exit, nextStyle.get('layers'));
  applySourceLayerChanges(map, nextStyle, sourcesDiff, layersDiff);
}

/* eslint-enable max-statements, complexity */

// Update a source in the map style
function updateStyleSource(map, update) {
  var newSource = update.source.toJS();
  if (newSource.type === 'geojson') {
    var oldSource = map.getSource(update.id);
    if (oldSource.type === 'geojson') {
      // update data if no other GeoJSONSource options were changed
      var oldOpts = oldSource.workerOptions;
      // GeoJSONSource class scales user options before assigning to workerOptions
      // https://github.com/mapbox/mapbox-gl-js/blob/master/src/source/geojson_source.js
      var scale = oldOpts.geojsonVtOptions.extent / 512;

      if ((newSource.maxzoom === undefined || newSource.maxzoom === oldOpts.geojsonVtOptions.maxZoom) && (newSource.buffer === undefined || newSource.buffer === oldOpts.geojsonVtOptions.buffer / scale) && (newSource.tolerance === undefined || newSource.tolerance === oldOpts.geojsonVtOptions.tolerance / scale) && (newSource.cluster === undefined || newSource.cluster === oldOpts.cluster) && (newSource.clusterRadius === undefined || newSource.clusterRadius === oldOpts.superclusterOptions.radius / scale) && (newSource.clusterMaxZoom === undefined || newSource.clusterMaxZoom === oldOpts.superclusterOptions.maxZoom)) {
        oldSource.setData(newSource.data);
        return;
      }
    }
  }

  map.removeSource(update.id);
  map.addSource(update.id, newSource);
}

function applySourceLayerChanges(map, nextStyle, sourcesDiff, layersDiff) {
  // TODO: It's rather difficult to determine style diffing in the presence
  // of refs. For now, if any style update has a ref, fallback to no diffing.
  // We can come back to this case if there's a solid usecase.
  if (layersDiff.updates.some(function (node) {
    return node.layer.get('ref');
  })) {
    map.setStyle(nextStyle.toJS());
    return;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = sourcesDiff.enter[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var enter = _step.value;

      map.addSource(enter.id, enter.source.toJS());
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = sourcesDiff.update[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var update = _step2.value;

      updateStyleSource(map, update);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = layersDiff.exiting[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var exit = _step3.value;

      if (map.style.getLayer(exit.id)) {
        map.removeLayer(exit.id);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = layersDiff.updates[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _update = _step4.value;

      if (!_update.enter) {
        // This is an old layer that needs to be updated. Remove the old layer
        // with the same id and add it back again.
        map.removeLayer(_update.id);
      }
      map.addLayer(_update.layer.toJS(), _update.before);
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = sourcesDiff.exit[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var _exit = _step5.value;

      map.removeSource(_exit.id);
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5.return) {
        _iterator5.return();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }
}

/* eslint-disable max-len */
function checkForEqualLayerSourceChanges(sourceExit, nextLayers) {
  var sourceIds = sourceExit.map(function (s) {
    return s.id;
  });
  var layersNotRemoved = nextLayers.filter(function (lyr) {
    return sourceIds.includes(lyr.get('source'));
  });
  if (layersNotRemoved.size) {
    // because of this, no source/layer changes will take effect if there is an error
    throw new Error('You must remove any layers associated with sources you are removing: ' + layersNotRemoved.map(function (l) {
      return l.get('id');
    }).toJS().join(''));
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9zdHlsZS11dGlscy5qcyJdLCJuYW1lcyI6WyJpc0ltbXV0YWJsZU1hcCIsImRpZmZTdHlsZXMiLCJnZXRJbnRlcmFjdGl2ZUxheWVySWRzIiwibWFwU3R5bGUiLCJpbnRlcmFjdGl2ZUxheWVySWRzIiwiaGFzIiwiZ2V0IiwiZmlsdGVyIiwibCIsIm1hcCIsInRvSlMiLCJBcnJheSIsImlzQXJyYXkiLCJsYXllcnMiLCJpbnRlcmFjdGl2ZSIsImlkIiwic2V0RGlmZlN0eWxlIiwicHJldlN0eWxlIiwibmV4dFN0eWxlIiwicHJldktleXNNYXAiLCJzdHlsZUtleXNNYXAiLCJuZXh0S2V5c01hcCIsInN0eWxlIiwiZGVsZXRlIiwicHJvcHNPdGhlclRoYW5MYXllcnNPclNvdXJjZXNEaWZmZXIiLCJwcmV2S2V5c0xpc3QiLCJPYmplY3QiLCJrZXlzIiwibmV4dEtleXNMaXN0IiwibGVuZ3RoIiwic29tZSIsImtleSIsInNldFN0eWxlIiwic291cmNlc0RpZmYiLCJsYXllcnNEaWZmIiwiY2hlY2tGb3JFcXVhbExheWVyU291cmNlQ2hhbmdlcyIsImV4aXQiLCJhcHBseVNvdXJjZUxheWVyQ2hhbmdlcyIsInVwZGF0ZVN0eWxlU291cmNlIiwidXBkYXRlIiwibmV3U291cmNlIiwic291cmNlIiwidHlwZSIsIm9sZFNvdXJjZSIsImdldFNvdXJjZSIsIm9sZE9wdHMiLCJ3b3JrZXJPcHRpb25zIiwic2NhbGUiLCJnZW9qc29uVnRPcHRpb25zIiwiZXh0ZW50IiwibWF4em9vbSIsInVuZGVmaW5lZCIsIm1heFpvb20iLCJidWZmZXIiLCJ0b2xlcmFuY2UiLCJjbHVzdGVyIiwiY2x1c3RlclJhZGl1cyIsInN1cGVyY2x1c3Rlck9wdGlvbnMiLCJyYWRpdXMiLCJjbHVzdGVyTWF4Wm9vbSIsInNldERhdGEiLCJkYXRhIiwicmVtb3ZlU291cmNlIiwiYWRkU291cmNlIiwidXBkYXRlcyIsIm5vZGUiLCJsYXllciIsImVudGVyIiwiZXhpdGluZyIsImdldExheWVyIiwicmVtb3ZlTGF5ZXIiLCJhZGRMYXllciIsImJlZm9yZSIsInNvdXJjZUV4aXQiLCJuZXh0TGF5ZXJzIiwic291cmNlSWRzIiwicyIsImxheWVyc05vdFJlbW92ZWQiLCJpbmNsdWRlcyIsImx5ciIsInNpemUiLCJFcnJvciIsImpvaW4iXSwibWFwcGluZ3MiOiJBQUFBLE9BQU9BLGNBQVAsTUFBMkIsb0JBQTNCO0FBQ0EsT0FBT0MsVUFBUCxNQUF1QixlQUF2Qjs7QUFFQSxPQUFPLFNBQVNDLHNCQUFULENBQWdDQyxRQUFoQyxFQUEwQztBQUMvQyxNQUFJQyxzQkFBc0IsSUFBMUI7O0FBRUEsTUFBSUosZUFBZUcsUUFBZixLQUE0QkEsU0FBU0UsR0FBVCxDQUFhLFFBQWIsQ0FBaEMsRUFBd0Q7QUFDdERELDBCQUFzQkQsU0FBU0csR0FBVCxDQUFhLFFBQWIsRUFDbkJDLE1BRG1CLENBQ1o7QUFBQSxhQUFLQyxFQUFFRixHQUFGLENBQU0sYUFBTixDQUFMO0FBQUEsS0FEWSxFQUVuQkcsR0FGbUIsQ0FFZjtBQUFBLGFBQUtELEVBQUVGLEdBQUYsQ0FBTSxJQUFOLENBQUw7QUFBQSxLQUZlLEVBR25CSSxJQUhtQixFQUF0QjtBQUlELEdBTEQsTUFLTyxJQUFJQyxNQUFNQyxPQUFOLENBQWNULFNBQVNVLE1BQXZCLENBQUosRUFBb0M7QUFDekNULDBCQUFzQkQsU0FBU1UsTUFBVCxDQUFnQk4sTUFBaEIsQ0FBdUI7QUFBQSxhQUFLQyxFQUFFTSxXQUFQO0FBQUEsS0FBdkIsRUFDbkJMLEdBRG1CLENBQ2Y7QUFBQSxhQUFLRCxFQUFFTyxFQUFQO0FBQUEsS0FEZSxDQUF0QjtBQUVEOztBQUVELFNBQU9YLG1CQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFNBQVNZLFlBQVQsQ0FBc0JDLFNBQXRCLEVBQWlDQyxTQUFqQyxFQUE0Q1QsR0FBNUMsRUFBaUQ7QUFDdEQsTUFBTVUsY0FBY0YsYUFBYUcsYUFBYUgsU0FBYixDQUFiLElBQXdDLEVBQTVEO0FB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Q0FBbkIsQ0FBUDtBQUFBLEdBQWxCLENBQXpCO0FBQ0EsTUFBSXVFLGlCQUFpQkcsSUFBckIsRUFBMkI7QUFDekI7QUFDQSxVQUFNLElBQUlDLEtBQUosMkVBQWtGSixpQkFBaUJwRSxHQUFqQixDQUFxQjtBQUFBLGFBQUtELEVBQUVGLEdBQUYsQ0FBTSxJQUFOLENBQUw7QUFBQSxLQUFyQixFQUF1Q0ksSUFBdkMsR0FBOEN3RSxJQUE5QyxDQUFtRCxFQUFuRCxDQUFsRixDQUFOO0FBQ0Q7QUFDRiIsImZpbGUiOiJzdHlsZS11dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpc0ltbXV0YWJsZU1hcCBmcm9tICcuL2lzLWltbXV0YWJsZS1tYXAnO1xuaW1wb3J0IGRpZmZTdHlsZXMgZnJvbSAnLi9kaWZmLXN0eWxlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcmFjdGl2ZUxheWVySWRzKG1hcFN0eWxlKSB7XG4gIGxldCBpbnRlcmFjdGl2ZUxheWVySWRzID0gbnVsbDtcblxuICBpZiAoaXNJbW11dGFibGVNYXAobWFwU3R5bGUpICYmIG1hcFN0eWxlLmhhcygnbGF5ZXJzJykpIHtcbiAgICBpbnRlcmFjdGl2ZUxheWVySWRzID0gbWFwU3R5bGUuZ2V0KCdsYXllcnMnKVxuICAgICAgLmZpbHRlcihsID0+IGwuZ2V0KCdpbnRlcmFjdGl2ZScpKVxuICAgICAgLm1hcChsID0+IGwuZ2V0KCdpZCcpKVxuICAgICAgLnRvSlMoKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1hcFN0eWxlLmxheWVycykpIHtcbiAgICBpbnRlcmFjdGl2ZUxheWVySWRzID0gbWFwU3R5bGUubGF5ZXJzLmZpbHRlcihsID0+IGwuaW50ZXJhY3RpdmUpXG4gICAgICAubWFwKGwgPT4gbC5pZCk7XG4gIH1cblxuICByZXR1cm4gaW50ZXJhY3RpdmVMYXllcklkcztcbn1cblxuLy8gSW5kaXZpZHVhbGx5IHVwZGF0ZSB0aGUgbWFwcyBzb3VyY2UgYW5kIGxheWVycyB0aGF0IGhhdmUgY2hhbmdlZCBpZiBhbGxcbi8vIG90aGVyIHN0eWxlIHByb3BzIGhhdmVuJ3QgY2hhbmdlZC4gVGhpcyBwcmV2ZW50cyBmbGlja2luZyBvZiB0aGUgbWFwIHdoZW5cbi8vIHN0eWxlcyBvbmx5IGNoYW5nZSBzb3VyY2VzIG9yIGxheWVycy5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzLCBjb21wbGV4aXR5ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RGlmZlN0eWxlKHByZXZTdHlsZSwgbmV4dFN0eWxlLCBtYXApIHtcbiAgY29uc3QgcHJldktleXNNYXAgPSBwcmV2U3R5bGUgJiYgc3R5bGVLZXlzTWFwKHByZXZTdHlsZSkgfHwge307XG4gIGNvbnN0IG5leHRLZXlzTWFwID0gc3R5bGVLZXlzTWFwKG5leHRTdHlsZSk7XG4gIGZ1bmN0aW9uIHN0eWxlS2V5c01hcChzdHlsZSkge1xuICAgIHJldHVybiBzdHlsZS5tYXAoKCkgPT4gdHJ1ZSkuZGVsZXRlKCdsYXllcnMnKS5kZWxldGUoJ3NvdXJjZXMnKS50b0pTKCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvcHNPdGhlclRoYW5MYXllcnNPclNvdXJjZXNEaWZmZXIoKSB7XG4gICAgY29uc3QgcHJldktleXNMaXN0ID0gT2JqZWN0LmtleXMocHJldktleXNNYXApO1xuICAgIGNvbnN0IG5leHRLZXlzTGlzdCA9IE9iamVjdC5rZXlzKG5leHRLZXlzTWFwKTtcbiAgICBpZiAocHJldktleXNMaXN0Lmxlbmd0aCAhPT0gbmV4dEtleXNMaXN0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGBuZXh0U3R5bGVgIGFuZCBgcHJldlN0eWxlYCBzaG91bGQgbm90IGhhdmUgdGhlIHNhbWUgc2V0IG9mIHByb3BzLlxuICAgIGlmIChuZXh0S2V5c0xpc3Quc29tZShcbiAgICAgIGtleSA9PiBwcmV2U3R5bGUuZ2V0KGtleSkgIT09IG5leHRTdHlsZS5nZXQoa2V5KVxuICAgICAgLy8gQnV0IHRoZSB2YWx1ZSBvZiBvbmUgb2YgdGhvc2UgcHJvcHMgaXMgZGlmZmVyZW50LlxuICAgICkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIXByZXZTdHlsZSB8fCBwcm9wc090aGVyVGhhbkxheWVyc09yU291cmNlc0RpZmZlcigpKSB7XG4gICAgbWFwLnNldFN0eWxlKG5leHRTdHlsZS50b0pTKCkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtzb3VyY2VzRGlmZiwgbGF5ZXJzRGlmZn0gPSBkaWZmU3R5bGVzKHByZXZTdHlsZSwgbmV4dFN0eWxlKTtcbiAgY2hlY2tGb3JFcXVhbExheWVyU291cmNlQ2hhbmdlcyhzb3VyY2VzRGlmZi5leGl0LCBuZXh0U3R5bGUuZ2V0KCdsYXllcnMnKSk7XG4gIGFwcGx5U291cmNlTGF5ZXJDaGFuZ2VzKG1hcCwgbmV4dFN0eWxlLCBzb3VyY2VzRGlmZiwgbGF5ZXJzRGlmZik7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMsIGNvbXBsZXhpdHkgKi9cblxuLy8gVXBkYXRlIGEgc291cmNlIGluIHRoZSBtYXAgc3R5bGVcbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlU291cmNlKG1hcCwgdXBkYXRlKSB7XG4gIGNvbnN0IG5ld1NvdXJjZSA9IHVwZGF0ZS5zb3VyY2UudG9KUygpO1xuICBpZiAobmV3U291cmNlLnR5cGUgPT09ICdnZW9qc29uJykge1xuICAgIGNvbnN0IG9sZFNvdXJjZSA9IG1hcC5nZXRTb3VyY2UodXBkYXRlLmlkKTtcbiAgICBpZiAob2xkU291cmNlLnR5cGUgPT09ICdnZW9qc29uJykge1xuICAgICAgLy8gdXBkYXRlIGRhdGEgaWYgbm8gb3RoZXIgR2VvSlNPTlNvdXJjZSBvcHRpb25zIHdlcmUgY2hhbmdlZFxuICAgICAgY29uc3Qgb2xkT3B0cyA9IG9sZFNvdXJjZS53b3JrZXJPcHRpb25zO1xuICAgICAgLy8gR2VvSlNPTlNvdXJjZSBjbGFzcyBzY2FsZXMgdXNlciBvcHRpb25zIGJlZm9yZSBhc3NpZ25pbmcgdG8gd29ya2VyT3B0aW9uc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvYmxvYi9tYXN0ZXIvc3JjL3NvdXJjZS9nZW9qc29uX3NvdXJjZS5qc1xuICAgICAgY29uc3Qgc2NhbGUgPSBvbGRPcHRzLmdlb2pzb25WdE9wdGlvbnMuZXh0ZW50IC8gNTEyO1xuXG4gICAgICBpZiAoXG4gICAgICAgIChuZXdTb3VyY2UubWF4em9vbSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgbmV3U291cmNlLm1heHpvb20gPT09IG9sZE9wdHMuZ2VvanNvblZ0T3B0aW9ucy5tYXhab29tKSAmJlxuICAgICAgICAobmV3U291cmNlLmJ1ZmZlciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgbmV3U291cmNlLmJ1ZmZlciA9PT0gb2xkT3B0cy5nZW9qc29uVnRPcHRpb25zLmJ1ZmZlciAvIHNjYWxlKSAmJlxuICAgICAgICAobmV3U291cmNlLnRvbGVyYW5jZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgbmV3U291cmNlLnRvbGVyYW5jZSA9PT0gb2xkT3B0cy5nZW9qc29uVnRPcHRpb25zLnRvbGVyYW5jZSAvIHNjYWxlKSAmJlxuICAgICAgICAobmV3U291cmNlLmNsdXN0ZXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIG5ld1NvdXJjZS5jbHVzdGVyID09PSBvbGRPcHRzLmNsdXN0ZXIpICYmXG4gICAgICAgIChuZXdTb3VyY2UuY2x1c3RlclJhZGl1cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgbmV3U291cmNlLmNsdXN0ZXJSYWRpdXMgPT09IG9sZE9wdHMuc3VwZXJjbHVzdGVyT3B0aW9ucy5yYWRpdXMgLyBzY2FsZSkgJiZcbiAgICAgICAgKG5ld1NvdXJjZS5jbHVzdGVyTWF4Wm9vbSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgbmV3U291cmNlLmNsdXN0ZXJNYXhab29tID09PSBvbGRPcHRzLnN1cGVyY2x1c3Rlck9wdGlvbnMubWF4Wm9vbSlcbiAgICAgICkge1xuICAgICAgICBvbGRTb3VyY2Uuc2V0RGF0YShuZXdTb3VyY2UuZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBtYXAucmVtb3ZlU291cmNlKHVwZGF0ZS5pZCk7XG4gIG1hcC5hZGRTb3VyY2UodXBkYXRlLmlkLCBuZXdTb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBhcHBseVNvdXJjZUxheWVyQ2hhbmdlcyhtYXAsIG5leHRTdHlsZSwgc291cmNlc0RpZmYsIGxheWVyc0RpZmYpIHtcbi8vIFRPRE86IEl0J3MgcmF0aGVyIGRpZmZpY3VsdCB0byBkZXRlcm1pbmUgc3R5bGUgZGlmZmluZyBpbiB0aGUgcHJlc2VuY2VcbiAgLy8gb2YgcmVmcy4gRm9yIG5vdywgaWYgYW55IHN0eWxlIHVwZGF0ZSBoYXMgYSByZWYsIGZhbGxiYWNrIHRvIG5vIGRpZmZpbmcuXG4gIC8vIFdlIGNhbiBjb21lIGJhY2sgdG8gdGhpcyBjYXNlIGlmIHRoZXJlJ3MgYSBzb2xpZCB1c2VjYXNlLlxuICBpZiAobGF5ZXJzRGlmZi51cGRhdGVzLnNvbWUobm9kZSA9PiBub2RlLmxheWVyLmdldCgncmVmJykpKSB7XG4gICAgbWFwLnNldFN0eWxlKG5leHRTdHlsZS50b0pTKCkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAoY29uc3QgZW50ZXIgb2Ygc291cmNlc0RpZmYuZW50ZXIpIHtcbiAgICBtYXAuYWRkU291cmNlKGVudGVyLmlkLCBlbnRlci5zb3VyY2UudG9KUygpKTtcbiAgfVxuICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiBzb3VyY2VzRGlmZi51cGRhdGUpIHtcbiAgICB1cGRhdGVTdHlsZVNvdXJjZShtYXAsIHVwZGF0ZSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGV4aXQgb2YgbGF5ZXJzRGlmZi5leGl0aW5nKSB7XG4gICAgaWYgKG1hcC5zdHlsZS5nZXRMYXllcihleGl0LmlkKSkge1xuICAgICAgbWFwLnJlbW92ZUxheWVyKGV4aXQuaWQpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiBsYXllcnNEaWZmLnVwZGF0ZXMpIHtcbiAgICBpZiAoIXVwZGF0ZS5lbnRlcikge1xuICAgICAgLy8gVGhpcyBpcyBhbiBvbGQgbGF5ZXIgdGhhdCBuZWVkcyB0byBiZSB1cGRhdGVkLiBSZW1vdmUgdGhlIG9sZCBsYXllclxuICAgICAgLy8gd2l0aCB0aGUgc2FtZSBpZCBhbmQgYWRkIGl0IGJhY2sgYWdhaW4uXG4gICAgICBtYXAucmVtb3ZlTGF5ZXIodXBkYXRlLmlkKTtcbiAgICB9XG4gICAgbWFwLmFkZExheWVyKHVwZGF0ZS5sYXllci50b0pTKCksIHVwZGF0ZS5iZWZvcmUpO1xuICB9XG5cbiAgZm9yIChjb25zdCBleGl0IG9mIHNvdXJjZXNEaWZmLmV4aXQpIHtcbiAgICBtYXAucmVtb3ZlU291cmNlKGV4aXQuaWQpO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbmZ1bmN0aW9uIGNoZWNrRm9yRXF1YWxMYXllclNvdXJjZUNoYW5nZXMoc291cmNlRXhpdCwgbmV4dExheWVycykge1xuICBjb25zdCBzb3VyY2VJZHMgPSBzb3VyY2VFeGl0Lm1hcChzID0+IHMuaWQpO1xuICBjb25zdCBsYXllcnNOb3RSZW1vdmVkID0gbmV4dExheWVycy5maWx0ZXIobHlyID0+IHNvdXJjZUlkcy5pbmNsdWRlcyhseXIuZ2V0KCdzb3VyY2UnKSkpO1xuICBpZiAobGF5ZXJzTm90UmVtb3ZlZC5zaXplKSB7XG4gICAgLy8gYmVjYXVzZSBvZiB0aGlzLCBubyBzb3VyY2UvbGF5ZXIgY2hhbmdlcyB3aWxsIHRha2UgZWZmZWN0IGlmIHRoZXJlIGlzIGFuIGVycm9yXG4gICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCByZW1vdmUgYW55IGxheWVycyBhc3NvY2lhdGVkIHdpdGggc291cmNlcyB5b3UgYXJlIHJlbW92aW5nOiAke2xheWVyc05vdFJlbW92ZWQubWFwKGwgPT4gbC5nZXQoJ2lkJykpLnRvSlMoKS5qb2luKCcnKX1gKTtcbiAgfVxufVxuIl19
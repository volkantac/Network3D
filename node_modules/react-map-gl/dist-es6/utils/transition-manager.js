var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* global requestAnimationFrame, cancelAnimationFrame */
import assert from 'assert';
import { LinearInterpolator } from './transition';
import MapState from './map-state';

var noop = function noop() {};

export var TRANSITION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
};

var DEFAULT_PROPS = {
  transitionDuration: 0,
  transitionEasing: function transitionEasing(t) {
    return t;
  },
  transitionInterpolator: new LinearInterpolator(),
  transitionInterruption: TRANSITION_EVENTS.BREAK,
  onTransitionStart: noop,
  onTransitionInterrupt: noop,
  onTransitionEnd: noop
};

var DEFAULT_STATE = {
  animation: null,
  propsInTransition: null,
  startProps: null,
  endProps: null
};

var TransitionManager = function () {
  function TransitionManager(props) {
    _classCallCheck(this, TransitionManager);

    this.props = props;
    this.state = DEFAULT_STATE;

    this._onTransitionFrame = this._onTransitionFrame.bind(this);
  }

  // Returns current transitioned viewport.


  _createClass(TransitionManager, [{
    key: 'getViewportInTransition',
    value: function getViewportInTransition() {
      return this.state.propsInTransition;
    }

    // Process the viewport change, either ignore or trigger a new transiton.
    // Return true if a new transition is triggered, false otherwise.

  }, {
    key: 'processViewportChange',
    value: function processViewportChange(nextProps) {
      var transitionTriggered = false;
      var currentProps = this.props;
      // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.
      this.props = nextProps;

      // NOTE: Be cautious re-ordering statements in this function.
      if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {
        return transitionTriggered;
      }

      var isTransitionInProgress = this._isTransitionInProgress();

      if (this._isTransitionEnabled(nextProps)) {
        var startProps = Object.assign({}, currentProps, this.state.interruption === TRANSITION_EVENTS.SNAP_TO_END ? this.state.endProps : this.state.propsInTransition);

        if (isTransitionInProgress) {
          currentProps.onTransitionInterrupt();
        }
        nextProps.onTransitionStart();

        this._triggerTransition(startProps, nextProps);

        transitionTriggered = true;
      } else if (isTransitionInProgress) {
        currentProps.onTransitionInterrupt();
        this._endTransition();
      }

      return transitionTriggered;
    }

    // Helper methods

  }, {
    key: '_isTransitionInProgress',
    value: function _isTransitionInProgress() {
      return Boolean(this.state.propsInTransition);
    }
  }, {
    key: '_isTransitionEnabled',
    value: function _isTransitionEnabled(props) {
      return props.transitionDuration > 0 && Boolean(props.transitionInterpolator);
    }
  }, {
    key: '_isUpdateDueToCurrentTransition',
    value: function _isUpdateDueToCurrentTransition(props) {
      if (this.state.propsInTransition) {
        return this.state.interpolator.arePropsEqual(props, this.state.propsInTransition);
      }
      return false;
    }
  }, {
    key: '_shouldIgnoreViewportChange',
    value: function _shouldIgnoreViewportChange(currentProps, nextProps) {
      if (this._isTransitionInProgress()) {
        // Ignore update if it is requested to be ignored
        return this.state.interruption === TRANSITION_EVENTS.IGNORE ||
        // Ignore update if it is due to current active transition.
        this._isUpdateDueToCurrentTransition(nextProps);
      } else if (this._isTransitionEnabled(nextProps)) {
        // Ignore if none of the viewport props changed.
        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
      }
      return true;
    }
  }, {
    key: '_triggerTransition',
    value: function _triggerTransition(startProps, endProps) {
      assert(this._isTransitionEnabled(endProps), 'Transition is not enabled');

      cancelAnimationFrame(this.state.animation);

      var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endProps);

      this.state = {
        // Save current transition props
        duration: endProps.transitionDuration,
        easing: endProps.transitionEasing,
        interpolator: endProps.transitionInterpolator,
        interruption: endProps.transitionInterruption,

        startTime: Date.now(),
        startProps: initialProps.start,
        endProps: initialProps.end,
        animation: null,
        propsInTransition: {}
      };

      this._onTransitionFrame();
    }
  }, {
    key: '_onTransitionFrame',
    value: function _onTransitionFrame() {
      // _updateViewport() may cancel the animation
      this.state.animation = requestAnimationFrame(this._onTransitionFrame);
      this._updateViewport();
    }
  }, {
    key: '_endTransition',
    value: function _endTransition() {
      cancelAnimationFrame(this.state.animation);
      this.state = DEFAULT_STATE;
    }
  }, {
    key: '_updateViewport',
    value: function _updateViewport() {
      // NOTE: Be cautious re-ordering statements in this function.
      var currentTime = Date.now();
      var _state = this.state,
          startTime = _state.startTime,
          duration = _state.duration,
          easing = _state.easing,
          interpolator = _state.interpolator,
          startProps = _state.startProps,
          endProps = _state.endProps;


      var shouldEnd = false;
      var t = (currentTime - startTime) / duration;
      if (t >= 1) {
        t = 1;
        shouldEnd = true;
      }
      t = easing(t);

      var viewport = interpolator.interpolateProps(startProps, endProps, t);
      // Normalize viewport props
      var mapState = new MapState(Object.assign({}, this.props, viewport));
      this.state.propsInTransition = mapState.getViewportProps();

      // TODO(deprecate): remove this check when `onChangeViewport` gets deprecated
      var onViewportChange = this.props.onViewportChange || this.props.onChangeViewport;
      if (onViewportChange) {
        onViewportChange(this.state.propsInTransition);
      }

      if (shouldEnd) {
        this._endTransition();
        this.props.onTransitionEnd();
      }
    }
  }]);

  return TransitionManager;
}();

export default TransitionManager;


TransitionManager.defaultProps = DEFAULT_PROPS;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy90cmFuc2l0aW9uLW1hbmFnZXIuanMiXSwibmFtZXMiOlsiYXNzZXJ0IiwiTGluZWFySW50ZXJwb2xhdG9yIiwiTWFwU3RhdGUiLCJub29wIiwiVFJBTlNJVElPTl9FVkVOVFMiLCJCUkVBSyIsIlNOQVBfVE9fRU5EIiwiSUdOT1JFIiwiREVGQVVMVF9QUk9QUyIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25FYXNpbmciLCJ0IiwidHJhbnNpdGlvbkludGVycG9sYXRvciIsInRyYW5zaXRpb25JbnRlcnJ1cHRpb24iLCJvblRyYW5zaXRpb25TdGFydCIsIm9uVHJhbnNpdGlvbkludGVycnVwdCIsIm9uVHJhbnNpdGlvbkVuZCIsIkRFRkFVTFRfU1RBVEUiLCJhbmltYXRpb24iLCJwcm9wc0luVHJhbnNpdGlvbiIsInN0YXJ0UHJvcHMiLCJlbmRQcm9wcyIsIlRyYW5zaXRpb25NYW5hZ2VyIiwicHJvcHMiLCJzdGF0ZSIsIl9vblRyYW5zaXRpb25GcmFtZSIsImJpbmQiLCJuZXh0UHJvcHMiLCJ0cmFuc2l0aW9uVHJpZ2dlcmVkIiwiY3VycmVudFByb3BzIiwiX3Nob3VsZElnbm9yZVZpZXdwb3J0Q2hhbmdlIiwiaXNUcmFuc2l0aW9uSW5Qcm9ncmVzcyIsIl9pc1RyYW5zaXRpb25JblByb2dyZXNzIiwiX2lzVHJhbnNpdGlvbkVuYWJsZWQiLCJPYmplY3QiLCJhc3NpZ24iLCJpbnRlcnJ1cHRpb24iLCJfdHJpZ2dlclRyYW5zaXRpb24iLCJfZW5kVHJhbnNpdGlvbiIsIkJvb2xlYW4iLCJpbnRlcnBvbGF0b3IiLCJhcmVQcm9wc0VxdWFsIiwiX2lzVXBkYXRlRHVlVG9DdXJyZW50VHJhbnNpdGlvbiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaW5pdGlhbFByb3BzIiwiaW5pdGlhbGl6ZVByb3BzIiwiZHVyYXRpb24iLCJlYXNpbmciLCJzdGFydFRpbWUiLCJEYXRlIiwibm93Iiwic3RhcnQiLCJlbmQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJfdXBkYXRlVmlld3BvcnQiLCJjdXJyZW50VGltZSIsInNob3VsZEVuZCIsInZpZXdwb3J0IiwiaW50ZXJwb2xhdGVQcm9wcyIsIm1hcFN0YXRlIiwiZ2V0Vmlld3BvcnRQcm9wcyIsIm9uVmlld3BvcnRDaGFuZ2UiLCJvbkNoYW5nZVZpZXdwb3J0IiwiZGVmYXVsdFByb3BzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxPQUFPQSxNQUFQLE1BQW1CLFFBQW5CO0FBQ0EsU0FBUUMsa0JBQVIsUUFBaUMsY0FBakM7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLGFBQXJCOztBQUVBLElBQU1DLE9BQU8sU0FBUEEsSUFBTyxHQUFNLENBQUUsQ0FBckI7O0FBRUEsT0FBTyxJQUFNQyxvQkFBb0I7QUFDL0JDLFNBQU8sQ0FEd0I7QUFFL0JDLGVBQWEsQ0FGa0I7QUFHL0JDLFVBQVE7QUFIdUIsQ0FBMUI7O0FBTVAsSUFBTUMsZ0JBQWdCO0FBQ3BCQyxzQkFBb0IsQ0FEQTtBQUVwQkMsb0JBQWtCO0FBQUEsV0FBS0MsQ0FBTDtBQUFBLEdBRkU7QUFHcEJDLDBCQUF3QixJQUFJWCxrQkFBSixFQUhKO0FBSXBCWSwwQkFBd0JULGtCQUFrQkMsS0FKdEI7QUFLcEJTLHFCQUFtQlgsSUFMQztBQU1wQlkseUJBQXVCWixJQU5IO0FBT3BCYSxtQkFBaUJiO0FBUEcsQ0FBdEI7O0FBVUEsSUFBTWMsZ0JBQWdCO0FBQ3BCQyxhQUFXLElBRFM7QUFFcEJDLHFCQUFtQixJQUZDO0FBR3BCQyxjQUFZLElBSFE7QUFJcEJDLFlBQVU7QUFKVSxDQUF0Qjs7SUFPcUJDLGlCO0FBQ25CLDZCQUFZQyxLQUFaLEVBQW1CO0FBQUE7O0FBQ2pCLFNBQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFNBQUtDLEtBQUwsR0FBYVAsYUFBYjs7QUFFQSxTQUFLUSxrQkFBTCxHQUEwQixLQUFLQSxrQkFBTCxDQUF3QkMsSUFBeEIsQ0FBNkIsSUFBN0IsQ0FBMUI7QUFDRDs7QUFFRDs7Ozs7OENBQzBCO0FBQ3hC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LFVBQU1DLG1CQUFtQixLQUFLdEMsS0FBTCxDQUFXc0MsZ0JBQVgsSUFBK0IsS0FBS3RDLEtBQUwsQ0FBV3VDLGdCQUFuRTtBQUNBLFVBQUlELGdCQUFKLEVBQXNCO0FBQ3BCQSx5QkFBaUIsS0FBS3JDLEtBQUwsQ0FBV0wsaUJBQTVCO0FBQ0Q7O0FBRUQsVUFBSXFDLFNBQUosRUFBZTtBQUNiLGFBQUtsQixjQUFMO0FBQ0EsYUFBS2YsS0FBTCxDQUFXUCxlQUFYO0FBQ0Q7QUFDRjs7Ozs7O2VBbEprQk0saUI7OztBQXFKckJBLGtCQUFrQnlDLFlBQWxCLEdBQWlDdkQsYUFBakMiLCJmaWxlIjoidHJhbnNpdGlvbi1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUgKi9cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7TGluZWFySW50ZXJwb2xhdG9yfSBmcm9tICcuL3RyYW5zaXRpb24nO1xuaW1wb3J0IE1hcFN0YXRlIGZyb20gJy4vbWFwLXN0YXRlJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG5leHBvcnQgY29uc3QgVFJBTlNJVElPTl9FVkVOVFMgPSB7XG4gIEJSRUFLOiAxLFxuICBTTkFQX1RPX0VORDogMixcbiAgSUdOT1JFOiAzXG59O1xuXG5jb25zdCBERUZBVUxUX1BST1BTID0ge1xuICB0cmFuc2l0aW9uRHVyYXRpb246IDAsXG4gIHRyYW5zaXRpb25FYXNpbmc6IHQgPT4gdCxcbiAgdHJhbnNpdGlvbkludGVycG9sYXRvcjogbmV3IExpbmVhckludGVycG9sYXRvcigpLFxuICB0cmFuc2l0aW9uSW50ZXJydXB0aW9uOiBUUkFOU0lUSU9OX0VWRU5UUy5CUkVBSyxcbiAgb25UcmFuc2l0aW9uU3RhcnQ6IG5vb3AsXG4gIG9uVHJhbnNpdGlvbkludGVycnVwdDogbm9vcCxcbiAgb25UcmFuc2l0aW9uRW5kOiBub29wXG59O1xuXG5jb25zdCBERUZBVUxUX1NUQVRFID0ge1xuICBhbmltYXRpb246IG51bGwsXG4gIHByb3BzSW5UcmFuc2l0aW9uOiBudWxsLFxuICBzdGFydFByb3BzOiBudWxsLFxuICBlbmRQcm9wczogbnVsbFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNpdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLnN0YXRlID0gREVGQVVMVF9TVEFURTtcblxuICAgIHRoaXMuX29uVHJhbnNpdGlvbkZyYW1lID0gdGhpcy5fb25UcmFuc2l0aW9uRnJhbWUuYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgY3VycmVudCB0cmFuc2l0aW9uZWQgdmlld3BvcnQuXG4gIGdldFZpZXdwb3J0SW5UcmFuc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnByb3BzSW5UcmFuc2l0aW9uO1xuICB9XG5cbiAgLy8gUHJvY2VzcyB0aGUgdmlld3BvcnQgY2hhbmdlLCBlaXRoZXIgaWdub3JlIG9yIHRyaWdnZXIgYSBuZXcgdHJhbnNpdG9uLlxuICAvLyBSZXR1cm4gdHJ1ZSBpZiBhIG5ldyB0cmFuc2l0aW9uIGlzIHRyaWdnZXJlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICBwcm9jZXNzVmlld3BvcnRDaGFuZ2UobmV4dFByb3BzKSB7XG4gICAgbGV0IHRyYW5zaXRpb25UcmlnZ2VyZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjdXJyZW50UHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIC8vIFNldCB0aGlzLnByb3BzIGhlcmUgYXMgJ190cmlnZ2VyVHJhbnNpdGlvbicgY2FsbHMgJ191cGRhdGVWaWV3cG9ydCcgdGhhdCB1c2VzIHRoaXMucHJvcHMuXG4gICAgdGhpcy5wcm9wcyA9IG5leHRQcm9wcztcblxuICAgIC8vIE5PVEU6IEJlIGNhdXRpb3VzIHJlLW9yZGVyaW5nIHN0YXRlbWVudHMgaW4gdGhpcyBmdW5jdGlvbi5cbiAgICBpZiAodGhpcy5fc2hvdWxkSWdub3JlVmlld3BvcnRDaGFuZ2UoY3VycmVudFByb3BzLCBuZXh0UHJvcHMpKSB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvblRyaWdnZXJlZDtcbiAgICB9XG5cbiAgICBjb25zdCBpc1RyYW5zaXRpb25JblByb2dyZXNzID0gdGhpcy5faXNUcmFuc2l0aW9uSW5Qcm9ncmVzcygpO1xuXG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbkVuYWJsZWQobmV4dFByb3BzKSkge1xuICAgICAgY29uc3Qgc3RhcnRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnRQcm9wcyxcbiAgICAgICAgdGhpcy5zdGF0ZS5pbnRlcnJ1cHRpb24gPT09IFRSQU5TSVRJT05fRVZFTlRTLlNOQVBfVE9fRU5EID9cbiAgICAgICAgdGhpcy5zdGF0ZS5lbmRQcm9wcyA6IHRoaXMuc3RhdGUucHJvcHNJblRyYW5zaXRpb25cbiAgICAgICk7XG5cbiAgICAgIGlmIChpc1RyYW5zaXRpb25JblByb2dyZXNzKSB7XG4gICAgICAgIGN1cnJlbnRQcm9wcy5vblRyYW5zaXRpb25JbnRlcnJ1cHQoKTtcbiAgICAgIH1cbiAgICAgIG5leHRQcm9wcy5vblRyYW5zaXRpb25TdGFydCgpO1xuXG4gICAgICB0aGlzLl90cmlnZ2VyVHJhbnNpdGlvbihzdGFydFByb3BzLCBuZXh0UHJvcHMpO1xuXG4gICAgICB0cmFuc2l0aW9uVHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzVHJhbnNpdGlvbkluUHJvZ3Jlc3MpIHtcbiAgICAgIGN1cnJlbnRQcm9wcy5vblRyYW5zaXRpb25JbnRlcnJ1cHQoKTtcbiAgICAgIHRoaXMuX2VuZFRyYW5zaXRpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNpdGlvblRyaWdnZXJlZDtcbiAgfVxuXG4gIC8vIEhlbHBlciBtZXRob2RzXG5cbiAgX2lzVHJhbnNpdGlvbkluUHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5zdGF0ZS5wcm9wc0luVHJhbnNpdGlvbik7XG4gIH1cblxuICBfaXNUcmFuc2l0aW9uRW5hYmxlZChwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50cmFuc2l0aW9uRHVyYXRpb24gPiAwICYmIEJvb2xlYW4ocHJvcHMudHJhbnNpdGlvbkludGVycG9sYXRvcik7XG4gIH1cblxuICBfaXNVcGRhdGVEdWVUb0N1cnJlbnRUcmFuc2l0aW9uKHByb3BzKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUucHJvcHNJblRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmludGVycG9sYXRvci5hcmVQcm9wc0VxdWFsKHByb3BzLCB0aGlzLnN0YXRlLnByb3BzSW5UcmFuc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgX3Nob3VsZElnbm9yZVZpZXdwb3J0Q2hhbmdlKGN1cnJlbnRQcm9wcywgbmV4dFByb3BzKSB7XG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbkluUHJvZ3Jlc3MoKSkge1xuICAgICAgLy8gSWdub3JlIHVwZGF0ZSBpZiBpdCBpcyByZXF1ZXN0ZWQgdG8gYmUgaWdub3JlZFxuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaW50ZXJydXB0aW9uID09PSBUUkFOU0lUSU9OX0VWRU5UUy5JR05PUkUgfHxcbiAgICAgICAgLy8gSWdub3JlIHVwZGF0ZSBpZiBpdCBpcyBkdWUgdG8gY3VycmVudCBhY3RpdmUgdHJhbnNpdGlvbi5cbiAgICAgICAgdGhpcy5faXNVcGRhdGVEdWVUb0N1cnJlbnRUcmFuc2l0aW9uKG5leHRQcm9wcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9pc1RyYW5zaXRpb25FbmFibGVkKG5leHRQcm9wcykpIHtcbiAgICAgIC8vIElnbm9yZSBpZiBub25lIG9mIHRoZSB2aWV3cG9ydCBwcm9wcyBjaGFuZ2VkLlxuICAgICAgcmV0dXJuIG5leHRQcm9wcy50cmFuc2l0aW9uSW50ZXJwb2xhdG9yLmFyZVByb3BzRXF1YWwoY3VycmVudFByb3BzLCBuZXh0UHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF90cmlnZ2VyVHJhbnNpdGlvbihzdGFydFByb3BzLCBlbmRQcm9wcykge1xuICAgIGFzc2VydCh0aGlzLl9pc1RyYW5zaXRpb25FbmFibGVkKGVuZFByb3BzKSwgJ1RyYW5zaXRpb24gaXMgbm90IGVuYWJsZWQnKTtcblxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc3RhdGUuYW5pbWF0aW9uKTtcblxuICAgIGNvbnN0IGluaXRpYWxQcm9wcyA9IGVuZFByb3BzLnRyYW5zaXRpb25JbnRlcnBvbGF0b3IuaW5pdGlhbGl6ZVByb3BzKFxuICAgICAgc3RhcnRQcm9wcyxcbiAgICAgIGVuZFByb3BzXG4gICAgKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAvLyBTYXZlIGN1cnJlbnQgdHJhbnNpdGlvbiBwcm9wc1xuICAgICAgZHVyYXRpb246IGVuZFByb3BzLnRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgIGVhc2luZzogZW5kUHJvcHMudHJhbnNpdGlvbkVhc2luZyxcbiAgICAgIGludGVycG9sYXRvcjogZW5kUHJvcHMudHJhbnNpdGlvbkludGVycG9sYXRvcixcbiAgICAgIGludGVycnVwdGlvbjogZW5kUHJvcHMudHJhbnNpdGlvbkludGVycnVwdGlvbixcblxuICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgc3RhcnRQcm9wczogaW5pdGlhbFByb3BzLnN0YXJ0LFxuICAgICAgZW5kUHJvcHM6IGluaXRpYWxQcm9wcy5lbmQsXG4gICAgICBhbmltYXRpb246IG51bGwsXG4gICAgICBwcm9wc0luVHJhbnNpdGlvbjoge31cbiAgICB9O1xuXG4gICAgdGhpcy5fb25UcmFuc2l0aW9uRnJhbWUoKTtcbiAgfVxuXG4gIF9vblRyYW5zaXRpb25GcmFtZSgpIHtcbiAgICAvLyBfdXBkYXRlVmlld3BvcnQoKSBtYXkgY2FuY2VsIHRoZSBhbmltYXRpb25cbiAgICB0aGlzLnN0YXRlLmFuaW1hdGlvbiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9vblRyYW5zaXRpb25GcmFtZSk7XG4gICAgdGhpcy5fdXBkYXRlVmlld3BvcnQoKTtcbiAgfVxuXG4gIF9lbmRUcmFuc2l0aW9uKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc3RhdGUuYW5pbWF0aW9uKTtcbiAgICB0aGlzLnN0YXRlID0gREVGQVVMVF9TVEFURTtcbiAgfVxuXG4gIF91cGRhdGVWaWV3cG9ydCgpIHtcbiAgICAvLyBOT1RFOiBCZSBjYXV0aW91cyByZS1vcmRlcmluZyBzdGF0ZW1lbnRzIGluIHRoaXMgZnVuY3Rpb24uXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHtzdGFydFRpbWUsIGR1cmF0aW9uLCBlYXNpbmcsIGludGVycG9sYXRvciwgc3RhcnRQcm9wcywgZW5kUHJvcHN9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGxldCBzaG91bGRFbmQgPSBmYWxzZTtcbiAgICBsZXQgdCA9IChjdXJyZW50VGltZSAtIHN0YXJ0VGltZSkgLyBkdXJhdGlvbjtcbiAgICBpZiAodCA+PSAxKSB7XG4gICAgICB0ID0gMTtcbiAgICAgIHNob3VsZEVuZCA9IHRydWU7XG4gICAgfVxuICAgIHQgPSBlYXNpbmcodCk7XG5cbiAgICBjb25zdCB2aWV3cG9ydCA9IGludGVycG9sYXRvci5pbnRlcnBvbGF0ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0KTtcbiAgICAgIC8vIE5vcm1hbGl6ZSB2aWV3cG9ydCBwcm9wc1xuICAgIGNvbnN0IG1hcFN0YXRlID0gbmV3IE1hcFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHZpZXdwb3J0KSk7XG4gICAgdGhpcy5zdGF0ZS5wcm9wc0luVHJhbnNpdGlvbiA9IG1hcFN0YXRlLmdldFZpZXdwb3J0UHJvcHMoKTtcblxuICAgIC8vIFRPRE8oZGVwcmVjYXRlKTogcmVtb3ZlIHRoaXMgY2hlY2sgd2hlbiBgb25DaGFuZ2VWaWV3cG9ydGAgZ2V0cyBkZXByZWNhdGVkXG4gICAgY29uc3Qgb25WaWV3cG9ydENoYW5nZSA9IHRoaXMucHJvcHMub25WaWV3cG9ydENoYW5nZSB8fCB0aGlzLnByb3BzLm9uQ2hhbmdlVmlld3BvcnQ7XG4gICAgaWYgKG9uVmlld3BvcnRDaGFuZ2UpIHtcbiAgICAgIG9uVmlld3BvcnRDaGFuZ2UodGhpcy5zdGF0ZS5wcm9wc0luVHJhbnNpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZEVuZCkge1xuICAgICAgdGhpcy5fZW5kVHJhbnNpdGlvbigpO1xuICAgICAgdGhpcy5wcm9wcy5vblRyYW5zaXRpb25FbmQoKTtcbiAgICB9XG4gIH1cbn1cblxuVHJhbnNpdGlvbk1hbmFnZXIuZGVmYXVsdFByb3BzID0gREVGQVVMVF9QUk9QUztcbiJdfQ==
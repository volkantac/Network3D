var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import WebMercatorViewport, { normalizeViewportProps } from 'viewport-mercator-project';
import assert from 'assert';

// MAPBOX LIMITS
export var MAPBOX_LIMITS = {
  minZoom: 0,
  maxZoom: 20,
  minPitch: 0,
  maxPitch: 60
};

var DEFAULT_STATE = {
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

/* Utils */
function clamp(value, min, max) {
  return value < min ? min : value > max ? max : value;
}

var MapState = function () {
  function MapState() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        _ref$bearing = _ref.bearing,
        bearing = _ref$bearing === undefined ? DEFAULT_STATE.bearing : _ref$bearing,
        _ref$pitch = _ref.pitch,
        pitch = _ref$pitch === undefined ? DEFAULT_STATE.pitch : _ref$pitch,
        _ref$altitude = _ref.altitude,
        altitude = _ref$altitude === undefined ? DEFAULT_STATE.altitude : _ref$altitude,
        _ref$maxZoom = _ref.maxZoom,
        maxZoom = _ref$maxZoom === undefined ? MAPBOX_LIMITS.maxZoom : _ref$maxZoom,
        _ref$minZoom = _ref.minZoom,
        minZoom = _ref$minZoom === undefined ? MAPBOX_LIMITS.minZoom : _ref$minZoom,
        _ref$maxPitch = _ref.maxPitch,
        maxPitch = _ref$maxPitch === undefined ? MAPBOX_LIMITS.maxPitch : _ref$maxPitch,
        _ref$minPitch = _ref.minPitch,
        minPitch = _ref$minPitch === undefined ? MAPBOX_LIMITS.minPitch : _ref$minPitch,
        transitionDuration = _ref.transitionDuration,
        transitionEasing = _ref.transitionEasing,
        transitionInterpolator = _ref.transitionInterpolator,
        transitionInterruption = _ref.transitionInterruption,
        startPanLngLat = _ref.startPanLngLat,
        startZoomLngLat = _ref.startZoomLngLat,
        startBearing = _ref.startBearing,
        startPitch = _ref.startPitch,
        startZoom = _ref.startZoom;

    _classCallCheck(this, MapState);

    assert(Number.isFinite(width), '`width` must be supplied');
    assert(Number.isFinite(height), '`height` must be supplied');
    assert(Number.isFinite(longitude), '`longitude` must be supplied');
    assert(Number.isFinite(latitude), '`latitude` must be supplied');
    assert(Number.isFinite(zoom), '`zoom` must be supplied');

    this._viewportProps = this._applyConstraints({
      width: width,
      height: height,
      latitude: latitude,
      longitude: longitude,
      zoom: zoom,
      bearing: bearing,
      pitch: pitch,
      altitude: altitude,
      maxZoom: maxZoom,
      minZoom: minZoom,
      maxPitch: maxPitch,
      minPitch: minPitch,
      transitionDuration: transitionDuration,
      transitionEasing: transitionEasing,
      transitionInterpolator: transitionInterpolator,
      transitionInterruption: transitionInterruption
    });

    this._interactiveState = {
      startPanLngLat: startPanLngLat,
      startZoomLngLat: startZoomLngLat,
      startBearing: startBearing,
      startPitch: startPitch,
      startZoom: startZoom
    };
  }

  /* Public API */

  _createClass(MapState, [{
    key: 'getViewportProps',
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: 'getInteractiveState',
    value: function getInteractiveState() {
      return this._interactiveState;
    }

    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'panStart',
    value: function panStart(_ref2) {
      var pos = _ref2.pos;

      return this._getUpdatedMapState({
        startPanLngLat: this._unproject(pos)
      });
    }

    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     * @param {[Number, Number], optional} startPos - where the pointer grabbed at
     *   the start of the operation. Must be supplied of `panStart()` was not called
     */

  }, {
    key: 'pan',
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;

      var startPanLngLat = this._interactiveState.startPanLngLat || this._unproject(startPos);

      if (!startPanLngLat) {
        return this;
      }

      var _calculateNewLngLat2 = this._calculateNewLngLat({ startPanLngLat: startPanLngLat, pos: pos }),
          _calculateNewLngLat3 = _slicedToArray(_calculateNewLngLat2, 2),
          longitude = _calculateNewLngLat3[0],
          latitude = _calculateNewLngLat3[1];

      return this._getUpdatedMapState({
        longitude: longitude,
        latitude: latitude
      });
    }

    /**
     * End panning
     * Must call if `panStart()` was called
     */

  }, {
    key: 'panEnd',
    value: function panEnd() {
      return this._getUpdatedMapState({
        startPanLngLat: null
      });
    }

    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the center is
     */

  }, {
    key: 'rotateStart',
    value: function rotateStart(_ref4) {
      var pos = _ref4.pos;

      return this._getUpdatedMapState({
        startBearing: this._viewportProps.bearing,
        startPitch: this._viewportProps.pitch
      });
    }

    /**
     * Rotate
     * @param {Number} deltaScaleX - a number between [-1, 1] specifying the
     *   change to bearing.
     * @param {Number} deltaScaleY - a number between [-1, 1] specifying the
     *   change to pitch. -1 sets to minPitch and 1 sets to maxPitch.
     */

  }, {
    key: 'rotate',
    value: function rotate(_ref5) {
      var _ref5$deltaScaleX = _ref5.deltaScaleX,
          deltaScaleX = _ref5$deltaScaleX === undefined ? 0 : _ref5$deltaScaleX,
          _ref5$deltaScaleY = _ref5.deltaScaleY,
          deltaScaleY = _ref5$deltaScaleY === undefined ? 0 : _ref5$deltaScaleY;
      var _interactiveState = this._interactiveState,
          startBearing = _interactiveState.startBearing,
          startPitch = _interactiveState.startPitch;


      if (!Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {
        return this;
      }

      var _calculateNewPitchAnd = this._calculateNewPitchAndBearing({
        deltaScaleX: deltaScaleX,
        deltaScaleY: deltaScaleY,
        startBearing: startBearing,
        startPitch: startPitch
      }),
          pitch = _calculateNewPitchAnd.pitch,
          bearing = _calculateNewPitchAnd.bearing;

      return this._getUpdatedMapState({
        bearing: bearing,
        pitch: pitch
      });
    }

    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */

  }, {
    key: 'rotateEnd',
    value: function rotateEnd() {
      return this._getUpdatedMapState({
        startBearing: null,
        startPitch: null
      });
    }

    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the center is
     */

  }, {
    key: 'zoomStart',
    value: function zoomStart(_ref6) {
      var pos = _ref6.pos;

      return this._getUpdatedMapState({
        startZoomLngLat: this._unproject(pos),
        startZoom: this._viewportProps.zoom
      });
    }

    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current center is
     * @param {[Number, Number]} startPos - the center position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */

  }, {
    key: 'zoom',
    value: function zoom(_ref7) {
      var pos = _ref7.pos,
          startPos = _ref7.startPos,
          scale = _ref7.scale;

      assert(scale > 0, '`scale` must be a positive number');

      // Make sure we zoom around the current mouse position rather than map center
      var _interactiveState2 = this._interactiveState,
          startZoom = _interactiveState2.startZoom,
          startZoomLngLat = _interactiveState2.startZoomLngLat;


      if (!Number.isFinite(startZoom)) {
        // We have two modes of zoom:
        // scroll zoom that are discrete events (transform from the current zoom level),
        // and pinch zoom that are continuous events (transform from the zoom level when
        // pinch started).
        // If startZoom state is defined, then use the startZoom state;
        // otherwise assume discrete zooming
        startZoom = this._viewportProps.zoom;
        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
      }

      // take the start lnglat and put it where the mouse is down.
      assert(startZoomLngLat, '`startZoomLngLat` prop is required ' + 'for zoom behavior to calculate where to position the map.');

      var zoom = this._calculateNewZoom({ scale: scale, startZoom: startZoom });

      var zoomedViewport = new WebMercatorViewport(Object.assign({}, this._viewportProps, { zoom: zoom }));

      var _zoomedViewport$getLo = zoomedViewport.getLocationAtPoint({ lngLat: startZoomLngLat, pos: pos }),
          _zoomedViewport$getLo2 = _slicedToArray(_zoomedViewport$getLo, 2),
          longitude = _zoomedViewport$getLo2[0],
          latitude = _zoomedViewport$getLo2[1];

      return this._getUpdatedMapState({
        zoom: zoom,
        longitude: longitude,
        latitude: latitude
      });
    }

    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */

  }, {
    key: 'zoomEnd',
    value: function zoomEnd() {
      return this._getUpdatedMapState({
        startZoomLngLat: null,
        startZoom: null
      });
    }

    /* Private methods */

  }, {
    key: '_getUpdatedMapState',
    value: function _getUpdatedMapState(newProps) {
      // Update _viewportProps
      return new MapState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }

    // Apply any constraints (mathematical or defined by _viewportProps) to map state

  }, {
    key: '_applyConstraints',
    value: function _applyConstraints(props) {
      // Ensure zoom is within specified range
      var maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          zoom = props.zoom;

      props.zoom = clamp(zoom, minZoom, maxZoom);

      // Ensure pitch is within specified range
      var maxPitch = props.maxPitch,
          minPitch = props.minPitch,
          pitch = props.pitch;

      props.pitch = clamp(pitch, minPitch, maxPitch);

      Object.assign(props, normalizeViewportProps(props));

      return props;
    }
  }, {
    key: '_unproject',
    value: function _unproject(pos) {
      var viewport = new WebMercatorViewport(this._viewportProps);
      return pos && viewport.unproject(pos);
    }

    // Calculate a new lnglat based on pixel dragging position

  }, {
    key: '_calculateNewLngLat',
    value: function _calculateNewLngLat(_ref8) {
      var startPanLngLat = _ref8.startPanLngLat,
          pos = _ref8.pos;

      var viewport = new WebMercatorViewport(this._viewportProps);
      return viewport.getMapCenterByLngLatPosition({ lngLat: startPanLngLat, pos: pos });
    }

    // Calculates new zoom

  }, {
    key: '_calculateNewZoom',
    value: function _calculateNewZoom(_ref9) {
      var scale = _ref9.scale,
          startZoom = _ref9.startZoom;
      var _viewportProps = this._viewportProps,
          maxZoom = _viewportProps.maxZoom,
          minZoom = _viewportProps.minZoom;

      var zoom = startZoom + Math.log2(scale);
      return clamp(zoom, minZoom, maxZoom);
    }

    // Calculates a new pitch and bearing from a position (coming from an event)

  }, {
    key: '_calculateNewPitchAndBearing',
    value: function _calculateNewPitchAndBearing(_ref10) {
      var deltaScaleX = _ref10.deltaScaleX,
          deltaScaleY = _ref10.deltaScaleY,
          startBearing = _ref10.startBearing,
          startPitch = _ref10.startPitch;

      // clamp deltaScaleY to [-1, 1] so that rotation is constrained between minPitch and maxPitch.
      // deltaScaleX does not need to be clamped as bearing does not have constraints.
      deltaScaleY = clamp(deltaScaleY, -1, 1);

      var _viewportProps2 = this._viewportProps,
          minPitch = _viewportProps2.minPitch,
          maxPitch = _viewportProps2.maxPitch;


      var bearing = startBearing + 180 * deltaScaleX;
      var pitch = startPitch;
      if (deltaScaleY > 0) {
        // Gradually increase pitch
        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
      } else if (deltaScaleY < 0) {
        // Gradually decrease pitch
        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
      }

      return {
        pitch: pitch,
        bearing: bearing
      };
    }
  }]);

  return MapState;
}();

export default MapState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9tYXAtc3RhdGUuanMiXSwibmFtZXMiOlsiV2ViTWVyY2F0b3JWaWV3cG9ydCIsIm5vcm1hbGl6ZVZpZXdwb3J0UHJvcHMiLCJhc3NlcnQiLCJNQVBCT1hfTElNSVRTIiwibWluWm9vbSIsIm1heFpvb20iLCJtaW5QaXRjaCIsIm1heFBpdGNoIiwiREVGQVVMVF9TVEFURSIsInBpdGNoIiwiYmVhcmluZyIsImFsdGl0dWRlIiwiY2xhbXAiLCJ2YWx1ZSIsIm1pbiIsIm1heCIsIk1hcFN0YXRlIiwid2lkdGgiLCJoZWlnaHQiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJ0cmFuc2l0aW9uRWFzaW5nIiwidHJhbnNpdGlvbkludGVycG9sYXRvciIsInRyYW5zaXRpb25JbnRlcnJ1cHRpb24iLCJzdGFydFBhbkxuZ0xhdCIsInN0YXJ0Wm9vbUxuZ0xhdCIsInN0YXJ0QmVhcmluZyIsInN0YXJ0UGl0Y2giLCJzdGFydFpvb20iLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIl92aWV3cG9ydFByb3BzIiwiX2FwcGx5Q29uc3RyYWludHMiLCJfaW50ZXJhY3RpdmVTdGF0ZSIsInBvcyIsIl9nZXRVcGRhdGVkTWFwU3RhdGUiLCJfdW5wcm9qZWN0Iiwic3RhcnRQb3MiLCJfY2FsY3VsYXRlTmV3TG5nTGF0IiwiZGVsdGFTY2FsZVgiLCJkZWx0YVNjYWxlWSIsIl9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmciLCJzY2FsZSIsIl9jYWxjdWxhdGVOZXdab29tIiwiem9vbWVkVmlld3BvcnQiLCJPYmplY3QiLCJhc3NpZ24iLCJnZXRMb2NhdGlvbkF0UG9pbnQiLCJsbmdMYXQiLCJuZXdQcm9wcyIsInByb3BzIiwidmlld3BvcnQiLCJ1bnByb2plY3QiLCJnZXRNYXBDZW50ZXJCeUxuZ0xhdFBvc2l0aW9uIiwiTWF0aCIsImxvZzIiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU9BLG1CQUFQ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SWEsY0FBYyxDQUFsQixFQUFxQjtBQUMxQjtBQUNBakMsZ0JBQVFvQixhQUFhYSxlQUFlcEMsV0FBV3VCLFVBQTFCLENBQXJCO0FBQ0Q7O0FBRUQsYUFBTztBQUNMcEIsb0JBREs7QUFFTEM7QUFGSyxPQUFQO0FBSUQ7Ozs7OztlQXZUa0JNLFEiLCJmaWxlIjoibWFwLXN0YXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFdlYk1lcmNhdG9yVmlld3BvcnQsIHtub3JtYWxpemVWaWV3cG9ydFByb3BzfSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuLy8gTUFQQk9YIExJTUlUU1xuZXhwb3J0IGNvbnN0IE1BUEJPWF9MSU1JVFMgPSB7XG4gIG1pblpvb206IDAsXG4gIG1heFpvb206IDIwLFxuICBtaW5QaXRjaDogMCxcbiAgbWF4UGl0Y2g6IDYwXG59O1xuXG5jb25zdCBERUZBVUxUX1NUQVRFID0ge1xuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcblxuLyogVXRpbHMgKi9cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiAodmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcFN0YXRlIHtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgLyoqIE1hcGJveCB2aWV3cG9ydCBwcm9wZXJ0aWVzICovXG4gICAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgdmlld3BvcnQgKi9cbiAgICB3aWR0aCxcbiAgICAvKiogVGhlIGhlaWdodCBvZiB0aGUgdmlld3BvcnQgKi9cbiAgICBoZWlnaHQsXG4gICAgLyoqIFRoZSBsYXRpdHVkZSBhdCB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCAqL1xuICAgIGxhdGl0dWRlLFxuICAgIC8qKiBUaGUgbG9uZ2l0dWRlIGF0IHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0ICovXG4gICAgbG9uZ2l0dWRlLFxuICAgIC8qKiBUaGUgdGlsZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuICovXG4gICAgem9vbSxcbiAgICAvKiogVGhlIGJlYXJpbmcgb2YgdGhlIHZpZXdwb3J0IGluIGRlZ3JlZXMgKi9cbiAgICBiZWFyaW5nID0gREVGQVVMVF9TVEFURS5iZWFyaW5nLFxuICAgIC8qKiBUaGUgcGl0Y2ggb2YgdGhlIHZpZXdwb3J0IGluIGRlZ3JlZXMgKi9cbiAgICBwaXRjaCA9IERFRkFVTFRfU1RBVEUucGl0Y2gsXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUgYWx0aXR1ZGUgb2YgdGhlIHZpZXdwb3J0IGNhbWVyYVxuICAgICAqIFVuaXQ6IG1hcCBoZWlnaHRzLCBkZWZhdWx0IDEuNVxuICAgICAqIE5vbi1wdWJsaWMgQVBJLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvaXNzdWVzLzExMzdcbiAgICAgKi9cbiAgICBhbHRpdHVkZSA9IERFRkFVTFRfU1RBVEUuYWx0aXR1ZGUsXG5cbiAgICAvKiogVmlld3BvcnQgY29uc3RyYWludHMgKi9cbiAgICBtYXhab29tID0gTUFQQk9YX0xJTUlUUy5tYXhab29tLFxuICAgIG1pblpvb20gPSBNQVBCT1hfTElNSVRTLm1pblpvb20sXG4gICAgbWF4UGl0Y2ggPSBNQVBCT1hfTElNSVRTLm1heFBpdGNoLFxuICAgIG1pblBpdGNoID0gTUFQQk9YX0xJTUlUUy5taW5QaXRjaCxcblxuICAgIC8qKiBUcmFuc2l0aW9uIHByb3BzICovXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgIHRyYW5zaXRpb25FYXNpbmcsXG4gICAgdHJhbnNpdGlvbkludGVycG9sYXRvcixcbiAgICB0cmFuc2l0aW9uSW50ZXJydXB0aW9uLFxuXG4gICAgLyoqIEludGVyYWN0aW9uIHN0YXRlcywgcmVxdWlyZWQgdG8gY2FsY3VsYXRlIGNoYW5nZSBkdXJpbmcgdHJhbnNmb3JtICovXG4gICAgLyogVGhlIHBvaW50IG9uIG1hcCBiZWluZyBncmFiYmVkIHdoZW4gdGhlIG9wZXJhdGlvbiBmaXJzdCBzdGFydGVkICovXG4gICAgc3RhcnRQYW5MbmdMYXQsXG4gICAgLyogQ2VudGVyIG9mIHRoZSB6b29tIHdoZW4gdGhlIG9wZXJhdGlvbiBmaXJzdCBzdGFydGVkICovXG4gICAgc3RhcnRab29tTG5nTGF0LFxuICAgIC8qKiBCZWFyaW5nIHdoZW4gY3VycmVudCBwZXJzcGVjdGl2ZSByb3RhdGUgb3BlcmF0aW9uIHN0YXJ0ZWQgKi9cbiAgICBzdGFydEJlYXJpbmcsXG4gICAgLyoqIFBpdGNoIHdoZW4gY3VycmVudCBwZXJzcGVjdGl2ZSByb3RhdGUgb3BlcmF0aW9uIHN0YXJ0ZWQgKi9cbiAgICBzdGFydFBpdGNoLFxuICAgIC8qKiBab29tIHdoZW4gY3VycmVudCB6b29tIG9wZXJhdGlvbiBzdGFydGVkICovXG4gICAgc3RhcnRab29tXG4gIH0gPSB7fSkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUod2lkdGgpLCAnYHdpZHRoYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShoZWlnaHQpLCAnYGhlaWdodGAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobG9uZ2l0dWRlKSwgJ2Bsb25naXR1ZGVgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxhdGl0dWRlKSwgJ2BsYXRpdHVkZWAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoem9vbSksICdgem9vbWAgbXVzdCBiZSBzdXBwbGllZCcpO1xuXG4gICAgdGhpcy5fdmlld3BvcnRQcm9wcyA9IHRoaXMuX2FwcGx5Q29uc3RyYWludHMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIHpvb20sXG4gICAgICBiZWFyaW5nLFxuICAgICAgcGl0Y2gsXG4gICAgICBhbHRpdHVkZSxcbiAgICAgIG1heFpvb20sXG4gICAgICBtaW5ab29tLFxuICAgICAgbWF4UGl0Y2gsXG4gICAgICBtaW5QaXRjaCxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgIHRyYW5zaXRpb25FYXNpbmcsXG4gICAgICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yLFxuICAgICAgdHJhbnNpdGlvbkludGVycnVwdGlvblxuICAgIH0pO1xuXG4gICAgdGhpcy5faW50ZXJhY3RpdmVTdGF0ZSA9IHtcbiAgICAgIHN0YXJ0UGFuTG5nTGF0LFxuICAgICAgc3RhcnRab29tTG5nTGF0LFxuICAgICAgc3RhcnRCZWFyaW5nLFxuICAgICAgc3RhcnRQaXRjaCxcbiAgICAgIHN0YXJ0Wm9vbVxuICAgIH07XG4gIH1cblxuICAvKiBQdWJsaWMgQVBJICovXG5cbiAgZ2V0Vmlld3BvcnRQcm9wcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRQcm9wcztcbiAgfVxuXG4gIGdldEludGVyYWN0aXZlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVyYWN0aXZlU3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcGFubmluZ1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgcG9pbnRlciBncmFic1xuICAgKi9cbiAgcGFuU3RhcnQoe3Bvc30pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgIHN0YXJ0UGFuTG5nTGF0OiB0aGlzLl91bnByb2plY3QocG9zKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhblxuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgcG9pbnRlciBpc1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl0sIG9wdGlvbmFsfSBzdGFydFBvcyAtIHdoZXJlIHRoZSBwb2ludGVyIGdyYWJiZWQgYXRcbiAgICogICB0aGUgc3RhcnQgb2YgdGhlIG9wZXJhdGlvbi4gTXVzdCBiZSBzdXBwbGllZCBvZiBgcGFuU3RhcnQoKWAgd2FzIG5vdCBjYWxsZWRcbiAgICovXG4gIHBhbih7cG9zLCBzdGFydFBvc30pIHtcbiAgICBjb25zdCBzdGFydFBhbkxuZ0xhdCA9IHRoaXMuX2ludGVyYWN0aXZlU3RhdGUuc3RhcnRQYW5MbmdMYXQgfHwgdGhpcy5fdW5wcm9qZWN0KHN0YXJ0UG9zKTtcblxuICAgIGlmICghc3RhcnRQYW5MbmdMYXQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IFtsb25naXR1ZGUsIGxhdGl0dWRlXSA9IHRoaXMuX2NhbGN1bGF0ZU5ld0xuZ0xhdCh7c3RhcnRQYW5MbmdMYXQsIHBvc30pO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCBwYW5uaW5nXG4gICAqIE11c3QgY2FsbCBpZiBgcGFuU3RhcnQoKWAgd2FzIGNhbGxlZFxuICAgKi9cbiAgcGFuRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgc3RhcnRQYW5MbmdMYXQ6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCByb3RhdGluZ1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgY2VudGVyIGlzXG4gICAqL1xuICByb3RhdGVTdGFydCh7cG9zfSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgc3RhcnRCZWFyaW5nOiB0aGlzLl92aWV3cG9ydFByb3BzLmJlYXJpbmcsXG4gICAgICBzdGFydFBpdGNoOiB0aGlzLl92aWV3cG9ydFByb3BzLnBpdGNoXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUm90YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVNjYWxlWCAtIGEgbnVtYmVyIGJldHdlZW4gWy0xLCAxXSBzcGVjaWZ5aW5nIHRoZVxuICAgKiAgIGNoYW5nZSB0byBiZWFyaW5nLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFTY2FsZVkgLSBhIG51bWJlciBiZXR3ZWVuIFstMSwgMV0gc3BlY2lmeWluZyB0aGVcbiAgICogICBjaGFuZ2UgdG8gcGl0Y2guIC0xIHNldHMgdG8gbWluUGl0Y2ggYW5kIDEgc2V0cyB0byBtYXhQaXRjaC5cbiAgICovXG4gIHJvdGF0ZSh7ZGVsdGFTY2FsZVggPSAwLCBkZWx0YVNjYWxlWSA9IDB9KSB7XG5cbiAgICBjb25zdCB7c3RhcnRCZWFyaW5nLCBzdGFydFBpdGNofSA9IHRoaXMuX2ludGVyYWN0aXZlU3RhdGU7XG5cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShzdGFydEJlYXJpbmcpIHx8ICFOdW1iZXIuaXNGaW5pdGUoc3RhcnRQaXRjaCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IHtwaXRjaCwgYmVhcmluZ30gPSB0aGlzLl9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmcoe1xuICAgICAgZGVsdGFTY2FsZVgsXG4gICAgICBkZWx0YVNjYWxlWSxcbiAgICAgIHN0YXJ0QmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2hcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgYmVhcmluZyxcbiAgICAgIHBpdGNoXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW5kIHJvdGF0aW5nXG4gICAqIE11c3QgY2FsbCBpZiBgcm90YXRlU3RhcnQoKWAgd2FzIGNhbGxlZFxuICAgKi9cbiAgcm90YXRlRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgc3RhcnRCZWFyaW5nOiBudWxsLFxuICAgICAgc3RhcnRQaXRjaDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHpvb21pbmdcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIGNlbnRlciBpc1xuICAgKi9cbiAgem9vbVN0YXJ0KHtwb3N9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICBzdGFydFpvb21MbmdMYXQ6IHRoaXMuX3VucHJvamVjdChwb3MpLFxuICAgICAgc3RhcnRab29tOiB0aGlzLl92aWV3cG9ydFByb3BzLnpvb21cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBab29tXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBjdXJyZW50IGNlbnRlciBpc1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHN0YXJ0UG9zIC0gdGhlIGNlbnRlciBwb3NpdGlvbiBhdFxuICAgKiAgIHRoZSBzdGFydCBvZiB0aGUgb3BlcmF0aW9uLiBNdXN0IGJlIHN1cHBsaWVkIG9mIGB6b29tU3RhcnQoKWAgd2FzIG5vdCBjYWxsZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gYSBudW1iZXIgYmV0d2VlbiBbMCwgMV0gc3BlY2lmeWluZyB0aGUgYWNjdW11bGF0ZWRcbiAgICogICByZWxhdGl2ZSBzY2FsZS5cbiAgICovXG4gIHpvb20oe3Bvcywgc3RhcnRQb3MsIHNjYWxlfSkge1xuICAgIGFzc2VydChzY2FsZSA+IDAsICdgc2NhbGVgIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSB6b29tIGFyb3VuZCB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvbiByYXRoZXIgdGhhbiBtYXAgY2VudGVyXG4gICAgbGV0IHtzdGFydFpvb20sIHN0YXJ0Wm9vbUxuZ0xhdH0gPSB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc3RhcnRab29tKSkge1xuICAgICAgLy8gV2UgaGF2ZSB0d28gbW9kZXMgb2Ygem9vbTpcbiAgICAgIC8vIHNjcm9sbCB6b29tIHRoYXQgYXJlIGRpc2NyZXRlIGV2ZW50cyAodHJhbnNmb3JtIGZyb20gdGhlIGN1cnJlbnQgem9vbSBsZXZlbCksXG4gICAgICAvLyBhbmQgcGluY2ggem9vbSB0aGF0IGFyZSBjb250aW51b3VzIGV2ZW50cyAodHJhbnNmb3JtIGZyb20gdGhlIHpvb20gbGV2ZWwgd2hlblxuICAgICAgLy8gcGluY2ggc3RhcnRlZCkuXG4gICAgICAvLyBJZiBzdGFydFpvb20gc3RhdGUgaXMgZGVmaW5lZCwgdGhlbiB1c2UgdGhlIHN0YXJ0Wm9vbSBzdGF0ZTtcbiAgICAgIC8vIG90aGVyd2lzZSBhc3N1bWUgZGlzY3JldGUgem9vbWluZ1xuICAgICAgc3RhcnRab29tID0gdGhpcy5fdmlld3BvcnRQcm9wcy56b29tO1xuICAgICAgc3RhcnRab29tTG5nTGF0ID0gdGhpcy5fdW5wcm9qZWN0KHN0YXJ0UG9zKSB8fCB0aGlzLl91bnByb2plY3QocG9zKTtcbiAgICB9XG5cbiAgICAvLyB0YWtlIHRoZSBzdGFydCBsbmdsYXQgYW5kIHB1dCBpdCB3aGVyZSB0aGUgbW91c2UgaXMgZG93bi5cbiAgICBhc3NlcnQoc3RhcnRab29tTG5nTGF0LCAnYHN0YXJ0Wm9vbUxuZ0xhdGAgcHJvcCBpcyByZXF1aXJlZCAnICtcbiAgICAgICdmb3Igem9vbSBiZWhhdmlvciB0byBjYWxjdWxhdGUgd2hlcmUgdG8gcG9zaXRpb24gdGhlIG1hcC4nKTtcblxuICAgIGNvbnN0IHpvb20gPSB0aGlzLl9jYWxjdWxhdGVOZXdab29tKHtzY2FsZSwgc3RhcnRab29tfSk7XG5cbiAgICBjb25zdCB6b29tZWRWaWV3cG9ydCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fdmlld3BvcnRQcm9wcywge3pvb219KVxuICAgICk7XG4gICAgY29uc3QgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdID0gem9vbWVkVmlld3BvcnQuZ2V0TG9jYXRpb25BdFBvaW50KHtsbmdMYXQ6IHN0YXJ0Wm9vbUxuZ0xhdCwgcG9zfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgIHpvb20sXG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCB6b29taW5nXG4gICAqIE11c3QgY2FsbCBpZiBgem9vbVN0YXJ0KClgIHdhcyBjYWxsZWRcbiAgICovXG4gIHpvb21FbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICBzdGFydFpvb21MbmdMYXQ6IG51bGwsXG4gICAgICBzdGFydFpvb206IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIC8qIFByaXZhdGUgbWV0aG9kcyAqL1xuXG4gIF9nZXRVcGRhdGVkTWFwU3RhdGUobmV3UHJvcHMpIHtcbiAgICAvLyBVcGRhdGUgX3ZpZXdwb3J0UHJvcHNcbiAgICByZXR1cm4gbmV3IE1hcFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3ZpZXdwb3J0UHJvcHMsIHRoaXMuX2ludGVyYWN0aXZlU3RhdGUsIG5ld1Byb3BzKSk7XG4gIH1cblxuICAvLyBBcHBseSBhbnkgY29uc3RyYWludHMgKG1hdGhlbWF0aWNhbCBvciBkZWZpbmVkIGJ5IF92aWV3cG9ydFByb3BzKSB0byBtYXAgc3RhdGVcbiAgX2FwcGx5Q29uc3RyYWludHMocHJvcHMpIHtcbiAgICAvLyBFbnN1cmUgem9vbSBpcyB3aXRoaW4gc3BlY2lmaWVkIHJhbmdlXG4gICAgY29uc3Qge21heFpvb20sIG1pblpvb20sIHpvb219ID0gcHJvcHM7XG4gICAgcHJvcHMuem9vbSA9IGNsYW1wKHpvb20sIG1pblpvb20sIG1heFpvb20pO1xuXG4gICAgLy8gRW5zdXJlIHBpdGNoIGlzIHdpdGhpbiBzcGVjaWZpZWQgcmFuZ2VcbiAgICBjb25zdCB7bWF4UGl0Y2gsIG1pblBpdGNoLCBwaXRjaH0gPSBwcm9wcztcbiAgICBwcm9wcy5waXRjaCA9IGNsYW1wKHBpdGNoLCBtaW5QaXRjaCwgbWF4UGl0Y2gpO1xuXG4gICAgT2JqZWN0LmFzc2lnbihwcm9wcywgbm9ybWFsaXplVmlld3BvcnRQcm9wcyhwcm9wcykpO1xuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgX3VucHJvamVjdChwb3MpIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHRoaXMuX3ZpZXdwb3J0UHJvcHMpO1xuICAgIHJldHVybiBwb3MgJiYgdmlld3BvcnQudW5wcm9qZWN0KHBvcyk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgYSBuZXcgbG5nbGF0IGJhc2VkIG9uIHBpeGVsIGRyYWdnaW5nIHBvc2l0aW9uXG4gIF9jYWxjdWxhdGVOZXdMbmdMYXQoe3N0YXJ0UGFuTG5nTGF0LCBwb3N9KSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh0aGlzLl92aWV3cG9ydFByb3BzKTtcbiAgICByZXR1cm4gdmlld3BvcnQuZ2V0TWFwQ2VudGVyQnlMbmdMYXRQb3NpdGlvbih7bG5nTGF0OiBzdGFydFBhbkxuZ0xhdCwgcG9zfSk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGVzIG5ldyB6b29tXG4gIF9jYWxjdWxhdGVOZXdab29tKHtzY2FsZSwgc3RhcnRab29tfSkge1xuICAgIGNvbnN0IHttYXhab29tLCBtaW5ab29tfSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG4gICAgY29uc3Qgem9vbSA9IHN0YXJ0Wm9vbSArIE1hdGgubG9nMihzY2FsZSk7XG4gICAgcmV0dXJuIGNsYW1wKHpvb20sIG1pblpvb20sIG1heFpvb20pO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlcyBhIG5ldyBwaXRjaCBhbmQgYmVhcmluZyBmcm9tIGEgcG9zaXRpb24gKGNvbWluZyBmcm9tIGFuIGV2ZW50KVxuICBfY2FsY3VsYXRlTmV3UGl0Y2hBbmRCZWFyaW5nKHtkZWx0YVNjYWxlWCwgZGVsdGFTY2FsZVksIHN0YXJ0QmVhcmluZywgc3RhcnRQaXRjaH0pIHtcbiAgICAvLyBjbGFtcCBkZWx0YVNjYWxlWSB0byBbLTEsIDFdIHNvIHRoYXQgcm90YXRpb24gaXMgY29uc3RyYWluZWQgYmV0d2VlbiBtaW5QaXRjaCBhbmQgbWF4UGl0Y2guXG4gICAgLy8gZGVsdGFTY2FsZVggZG9lcyBub3QgbmVlZCB0byBiZSBjbGFtcGVkIGFzIGJlYXJpbmcgZG9lcyBub3QgaGF2ZSBjb25zdHJhaW50cy5cbiAgICBkZWx0YVNjYWxlWSA9IGNsYW1wKGRlbHRhU2NhbGVZLCAtMSwgMSk7XG5cbiAgICBjb25zdCB7bWluUGl0Y2gsIG1heFBpdGNofSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG5cbiAgICBjb25zdCBiZWFyaW5nID0gc3RhcnRCZWFyaW5nICsgMTgwICogZGVsdGFTY2FsZVg7XG4gICAgbGV0IHBpdGNoID0gc3RhcnRQaXRjaDtcbiAgICBpZiAoZGVsdGFTY2FsZVkgPiAwKSB7XG4gICAgICAvLyBHcmFkdWFsbHkgaW5jcmVhc2UgcGl0Y2hcbiAgICAgIHBpdGNoID0gc3RhcnRQaXRjaCArIGRlbHRhU2NhbGVZICogKG1heFBpdGNoIC0gc3RhcnRQaXRjaCk7XG4gICAgfSBlbHNlIGlmIChkZWx0YVNjYWxlWSA8IDApIHtcbiAgICAgIC8vIEdyYWR1YWxseSBkZWNyZWFzZSBwaXRjaFxuICAgICAgcGl0Y2ggPSBzdGFydFBpdGNoIC0gZGVsdGFTY2FsZVkgKiAobWluUGl0Y2ggLSBzdGFydFBpdGNoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nXG4gICAgfTtcbiAgfVxuXG59XG4iXX0=
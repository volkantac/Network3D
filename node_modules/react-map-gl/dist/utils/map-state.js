'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MAPBOX_LIMITS = undefined;

var _log = require('babel-runtime/core-js/math/log2');

var _log2 = _interopRequireDefault(_log);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _isFinite = require('babel-runtime/core-js/number/is-finite');

var _isFinite2 = _interopRequireDefault(_isFinite);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _viewportMercatorProject = require('viewport-mercator-project');

var _viewportMercatorProject2 = _interopRequireDefault(_viewportMercatorProject);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// MAPBOX LIMITS
var MAPBOX_LIMITS = exports.MAPBOX_LIMITS = {
  minZoom: 0,
  maxZoom: 20,
  minPitch: 0,
  maxPitch: 60
};

var DEFAULT_STATE = {
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

/* Utils */
function clamp(value, min, max) {
  return value < min ? min : value > max ? max : value;
}

var MapState = function () {
  function MapState() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        _ref$bearing = _ref.bearing,
        bearing = _ref$bearing === undefined ? DEFAULT_STATE.bearing : _ref$bearing,
        _ref$pitch = _ref.pitch,
        pitch = _ref$pitch === undefined ? DEFAULT_STATE.pitch : _ref$pitch,
        _ref$altitude = _ref.altitude,
        altitude = _ref$altitude === undefined ? DEFAULT_STATE.altitude : _ref$altitude,
        _ref$maxZoom = _ref.maxZoom,
        maxZoom = _ref$maxZoom === undefined ? MAPBOX_LIMITS.maxZoom : _ref$maxZoom,
        _ref$minZoom = _ref.minZoom,
        minZoom = _ref$minZoom === undefined ? MAPBOX_LIMITS.minZoom : _ref$minZoom,
        _ref$maxPitch = _ref.maxPitch,
        maxPitch = _ref$maxPitch === undefined ? MAPBOX_LIMITS.maxPitch : _ref$maxPitch,
        _ref$minPitch = _ref.minPitch,
        minPitch = _ref$minPitch === undefined ? MAPBOX_LIMITS.minPitch : _ref$minPitch,
        transitionDuration = _ref.transitionDuration,
        transitionEasing = _ref.transitionEasing,
        transitionInterpolator = _ref.transitionInterpolator,
        transitionInterruption = _ref.transitionInterruption,
        startPanLngLat = _ref.startPanLngLat,
        startZoomLngLat = _ref.startZoomLngLat,
        startBearing = _ref.startBearing,
        startPitch = _ref.startPitch,
        startZoom = _ref.startZoom;

    (0, _classCallCheck3.default)(this, MapState);

    (0, _assert2.default)((0, _isFinite2.default)(width), '`width` must be supplied');
    (0, _assert2.default)((0, _isFinite2.default)(height), '`height` must be supplied');
    (0, _assert2.default)((0, _isFinite2.default)(longitude), '`longitude` must be supplied');
    (0, _assert2.default)((0, _isFinite2.default)(latitude), '`latitude` must be supplied');
    (0, _assert2.default)((0, _isFinite2.default)(zoom), '`zoom` must be supplied');

    this._viewportProps = this._applyConstraints({
      width: width,
      height: height,
      latitude: latitude,
      longitude: longitude,
      zoom: zoom,
      bearing: bearing,
      pitch: pitch,
      altitude: altitude,
      maxZoom: maxZoom,
      minZoom: minZoom,
      maxPitch: maxPitch,
      minPitch: minPitch,
      transitionDuration: transitionDuration,
      transitionEasing: transitionEasing,
      transitionInterpolator: transitionInterpolator,
      transitionInterruption: transitionInterruption
    });

    this._interactiveState = {
      startPanLngLat: startPanLngLat,
      startZoomLngLat: startZoomLngLat,
      startBearing: startBearing,
      startPitch: startPitch,
      startZoom: startZoom
    };
  }

  /* Public API */

  (0, _createClass3.default)(MapState, [{
    key: 'getViewportProps',
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: 'getInteractiveState',
    value: function getInteractiveState() {
      return this._interactiveState;
    }

    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'panStart',
    value: function panStart(_ref2) {
      var pos = _ref2.pos;

      return this._getUpdatedMapState({
        startPanLngLat: this._unproject(pos)
      });
    }

    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     * @param {[Number, Number], optional} startPos - where the pointer grabbed at
     *   the start of the operation. Must be supplied of `panStart()` was not called
     */

  }, {
    key: 'pan',
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;

      var startPanLngLat = this._interactiveState.startPanLngLat || this._unproject(startPos);

      if (!startPanLngLat) {
        return this;
      }

      var _calculateNewLngLat2 = this._calculateNewLngLat({ startPanLngLat: startPanLngLat, pos: pos }),
          _calculateNewLngLat3 = (0, _slicedToArray3.default)(_calculateNewLngLat2, 2),
          longitude = _calculateNewLngLat3[0],
          latitude = _calculateNewLngLat3[1];

      return this._getUpdatedMapState({
        longitude: longitude,
        latitude: latitude
      });
    }

    /**
     * End panning
     * Must call if `panStart()` was called
     */

  }, {
    key: 'panEnd',
    value: function panEnd() {
      return this._getUpdatedMapState({
        startPanLngLat: null
      });
    }

    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the center is
     */

  }, {
    key: 'rotateStart',
    value: function rotateStart(_ref4) {
      var pos = _ref4.pos;

      return this._getUpdatedMapState({
        startBearing: this._viewportProps.bearing,
        startPitch: this._viewportProps.pitch
      });
    }

    /**
     * Rotate
     * @param {Number} deltaScaleX - a number between [-1, 1] specifying the
     *   change to bearing.
     * @param {Number} deltaScaleY - a number between [-1, 1] specifying the
     *   change to pitch. -1 sets to minPitch and 1 sets to maxPitch.
     */

  }, {
    key: 'rotate',
    value: function rotate(_ref5) {
      var _ref5$deltaScaleX = _ref5.deltaScaleX,
          deltaScaleX = _ref5$deltaScaleX === undefined ? 0 : _ref5$deltaScaleX,
          _ref5$deltaScaleY = _ref5.deltaScaleY,
          deltaScaleY = _ref5$deltaScaleY === undefined ? 0 : _ref5$deltaScaleY;
      var _interactiveState = this._interactiveState,
          startBearing = _interactiveState.startBearing,
          startPitch = _interactiveState.startPitch;


      if (!(0, _isFinite2.default)(startBearing) || !(0, _isFinite2.default)(startPitch)) {
        return this;
      }

      var _calculateNewPitchAnd = this._calculateNewPitchAndBearing({
        deltaScaleX: deltaScaleX,
        deltaScaleY: deltaScaleY,
        startBearing: startBearing,
        startPitch: startPitch
      }),
          pitch = _calculateNewPitchAnd.pitch,
          bearing = _calculateNewPitchAnd.bearing;

      return this._getUpdatedMapState({
        bearing: bearing,
        pitch: pitch
      });
    }

    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */

  }, {
    key: 'rotateEnd',
    value: function rotateEnd() {
      return this._getUpdatedMapState({
        startBearing: null,
        startPitch: null
      });
    }

    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the center is
     */

  }, {
    key: 'zoomStart',
    value: function zoomStart(_ref6) {
      var pos = _ref6.pos;

      return this._getUpdatedMapState({
        startZoomLngLat: this._unproject(pos),
        startZoom: this._viewportProps.zoom
      });
    }

    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current center is
     * @param {[Number, Number]} startPos - the center position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */

  }, {
    key: 'zoom',
    value: function zoom(_ref7) {
      var pos = _ref7.pos,
          startPos = _ref7.startPos,
          scale = _ref7.scale;

      (0, _assert2.default)(scale > 0, '`scale` must be a positive number');

      // Make sure we zoom around the current mouse position rather than map center
      var _interactiveState2 = this._interactiveState,
          startZoom = _interactiveState2.startZoom,
          startZoomLngLat = _interactiveState2.startZoomLngLat;


      if (!(0, _isFinite2.default)(startZoom)) {
        // We have two modes of zoom:
        // scroll zoom that are discrete events (transform from the current zoom level),
        // and pinch zoom that are continuous events (transform from the zoom level when
        // pinch started).
        // If startZoom state is defined, then use the startZoom state;
        // otherwise assume discrete zooming
        startZoom = this._viewportProps.zoom;
        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
      }

      // take the start lnglat and put it where the mouse is down.
      (0, _assert2.default)(startZoomLngLat, '`startZoomLngLat` prop is required ' + 'for zoom behavior to calculate where to position the map.');

      var zoom = this._calculateNewZoom({ scale: scale, startZoom: startZoom });

      var zoomedViewport = new _viewportMercatorProject2.default((0, _assign2.default)({}, this._viewportProps, { zoom: zoom }));

      var _zoomedViewport$getLo = zoomedViewport.getLocationAtPoint({ lngLat: startZoomLngLat, pos: pos }),
          _zoomedViewport$getLo2 = (0, _slicedToArray3.default)(_zoomedViewport$getLo, 2),
          longitude = _zoomedViewport$getLo2[0],
          latitude = _zoomedViewport$getLo2[1];

      return this._getUpdatedMapState({
        zoom: zoom,
        longitude: longitude,
        latitude: latitude
      });
    }

    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */

  }, {
    key: 'zoomEnd',
    value: function zoomEnd() {
      return this._getUpdatedMapState({
        startZoomLngLat: null,
        startZoom: null
      });
    }

    /* Private methods */

  }, {
    key: '_getUpdatedMapState',
    value: function _getUpdatedMapState(newProps) {
      // Update _viewportProps
      return new MapState((0, _assign2.default)({}, this._viewportProps, this._interactiveState, newProps));
    }

    // Apply any constraints (mathematical or defined by _viewportProps) to map state

  }, {
    key: '_applyConstraints',
    value: function _applyConstraints(props) {
      // Ensure zoom is within specified range
      var maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          zoom = props.zoom;

      props.zoom = clamp(zoom, minZoom, maxZoom);

      // Ensure pitch is within specified range
      var maxPitch = props.maxPitch,
          minPitch = props.minPitch,
          pitch = props.pitch;

      props.pitch = clamp(pitch, minPitch, maxPitch);

      (0, _assign2.default)(props, (0, _viewportMercatorProject.normalizeViewportProps)(props));

      return props;
    }
  }, {
    key: '_unproject',
    value: function _unproject(pos) {
      var viewport = new _viewportMercatorProject2.default(this._viewportProps);
      return pos && viewport.unproject(pos);
    }

    // Calculate a new lnglat based on pixel dragging position

  }, {
    key: '_calculateNewLngLat',
    value: function _calculateNewLngLat(_ref8) {
      var startPanLngLat = _ref8.startPanLngLat,
          pos = _ref8.pos;

      var viewport = new _viewportMercatorProject2.default(this._viewportProps);
      return viewport.getMapCenterByLngLatPosition({ lngLat: startPanLngLat, pos: pos });
    }

    // Calculates new zoom

  }, {
    key: '_calculateNewZoom',
    value: function _calculateNewZoom(_ref9) {
      var scale = _ref9.scale,
          startZoom = _ref9.startZoom;
      var _viewportProps = this._viewportProps,
          maxZoom = _viewportProps.maxZoom,
          minZoom = _viewportProps.minZoom;

      var zoom = startZoom + (0, _log2.default)(scale);
      return clamp(zoom, minZoom, maxZoom);
    }

    // Calculates a new pitch and bearing from a position (coming from an event)

  }, {
    key: '_calculateNewPitchAndBearing',
    value: function _calculateNewPitchAndBearing(_ref10) {
      var deltaScaleX = _ref10.deltaScaleX,
          deltaScaleY = _ref10.deltaScaleY,
          startBearing = _ref10.startBearing,
          startPitch = _ref10.startPitch;

      // clamp deltaScaleY to [-1, 1] so that rotation is constrained between minPitch and maxPitch.
      // deltaScaleX does not need to be clamped as bearing does not have constraints.
      deltaScaleY = clamp(deltaScaleY, -1, 1);

      var _viewportProps2 = this._viewportProps,
          minPitch = _viewportProps2.minPitch,
          maxPitch = _viewportProps2.maxPitch;


      var bearing = startBearing + 180 * deltaScaleX;
      var pitch = startPitch;
      if (deltaScaleY > 0) {
        // Gradually increase pitch
        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
      } else if (deltaScaleY < 0) {
        // Gradually decrease pitch
        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
      }

      return {
        pitch: pitch,
        bearing: bearing
      };
    }
  }]);
  return MapState;
}();

exports.default = MapState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9tYXAtc3RhdGUuanMiXSwibmFtZXMiOlsiTUFQQk9YX0xJTUlUUyIsIm1pblpvb20iLCJtYXhab29tIiwibWluUGl0Y2giLCJtYXhQaXRjaCIsIkRFRkFVTFRfU1RBVEUiLCJwaXRjaCIsImJlYXJpbmciLCJhbHRpdHVkZSIsImNsYW1wIiwidmFsdWUiLCJtaW4iLCJtYXgiLCJNYXBTdGF0ZSIsIndpZHRoIiwiaGVpZ2h0IiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ6b29tIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvbkVhc2luZyIsInRyYW5zaXRpb25JbnRlcnBvbGF0b3IiLCJ0cmFuc2l0aW9uSW50ZXJydXB0aW9uIiwic3RhcnRQYW5MbmdMYXQiLCJzdGFydFpvb21MbmdMYXQiLCJzdGFydEJlYXJpbmciLCJzdGFydFBpdGNoIiwic3RhcnRab29tIiwiX3ZpZXdwb3J0UHJvcHMiLCJfYXBwbHlDb25zdHJhaW50cyIsIl9pbnRlcmFjdGl2ZVN0YXRlIiwicG9zIiwiX2dldFVwZGF0ZWRNYXBTdGF0ZSIsIl91bnByb2plY3QiLCJzdGFydFBvcyIsIl9jYWxjdWxhdGVOZXdMbmdMYXQiLCJkZWx0YVNjYWxlWCIsImRlbHRhU2NhbGVZIiwiX2NhbGN1bGF0ZU5ld1BpdGNoQW5kQmVhcmluZyIsInNjYWxlIiwiX2NhbGN1bGF0ZU5ld1pvb20iLCJ6b29tZWRWaWV3cG9ydCIsImdldExvY2F0aW9uQXRQb2ludCIsImxuZ0xhdCIsIm5ld1Byb3BzIiwicHJvcHMiLCJ2aWV3cG9ydCIsInVucHJvamVjdCIsImdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7Ozs7QUFFQTtBQUNPLElBQU1BLHdDQUFnQjtBQUMzQkMsV0FBUyxDQURrQjtBQUUzQkMsV0FBUyxFQUZrQjtBQUczQkMsWUFBVSxDQUhpQjtBQUkz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RXBDLFVBQU1pQixPQUFPUyxZQUFZLG1CQUFVWSxLQUFWLENBQXpCO0FBQ0EsYUFBTzlCLE1BQU1TLElBQU4sRUFBWWpCLE9BQVosRUFBcUJDLE9BQXJCLENBQVA7QUFDRDs7QUFFRDs7Ozt5REFDbUY7QUFBQSxVQUFyRGtDLFdBQXFELFVBQXJEQSxXQUFxRDtBQUFBLFVBQXhDQyxXQUF3QyxVQUF4Q0EsV0FBd0M7QUFBQSxVQUEzQlosWUFBMkIsVUFBM0JBLFlBQTJCO0FBQUEsVUFBYkMsVUFBYSxVQUFiQSxVQUFhOztBQUNqRjtBQUNBO0FBQ0FXLG9CQUFjNUIsTUFBTTRCLFdBQU4sRUFBbUIsQ0FBQyxDQUFwQixFQUF1QixDQUF2QixDQUFkOztBQUhpRiw0QkFLcEQsS0FBS1QsY0FMK0M7QUFBQSxVQUsxRXpCLFFBTDBFLG1CQUsxRUEsUUFMMEU7QUFBQSxVQUtoRUMsUUFMZ0UsbUJBS2hFQSxRQUxnRTs7O0FBT2pGLFVBQU1HLFVBQVVrQixlQUFlLE1BQU1XLFdBQXJDO0FBQ0EsVUFBSTlCLFFBQVFvQixVQUFaO0FBQ0EsVUFBSVcsY0FBYyxDQUFsQixFQUFxQjtBQUNuQjtBQUNBL0IsZ0JBQVFvQixhQUFhVyxlQUFlakMsV0FBV3NCLFVBQTFCLENBQXJCO0FBQ0QsT0FIRCxNQUdPLElBQUlXLGNBQWMsQ0FBbEIsRUFBcUI7QUFDMUI7QUFDQS9CLGdCQUFRb0IsYUFBYVcsZUFBZWxDLFdBQVd1QixVQUExQixDQUFyQjtBQUNEOztBQUVELGFBQU87QUFDTHBCLG9CQURLO0FBRUxDO0FBRkssT0FBUDtBQUlEOzs7OztrQkF2VGtCTSxRIiwiZmlsZSI6Im1hcC1zdGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBXZWJNZXJjYXRvclZpZXdwb3J0LCB7bm9ybWFsaXplVmlld3BvcnRQcm9wc30gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8vIE1BUEJPWCBMSU1JVFNcbmV4cG9ydCBjb25zdCBNQVBCT1hfTElNSVRTID0ge1xuICBtaW5ab29tOiAwLFxuICBtYXhab29tOiAyMCxcbiAgbWluUGl0Y2g6IDAsXG4gIG1heFBpdGNoOiA2MFxufTtcblxuY29uc3QgREVGQVVMVF9TVEFURSA9IHtcbiAgcGl0Y2g6IDAsXG4gIGJlYXJpbmc6IDAsXG4gIGFsdGl0dWRlOiAxLjVcbn07XG5cbi8qIFV0aWxzICovXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogKHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXBTdGF0ZSB7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8qKiBNYXBib3ggdmlld3BvcnQgcHJvcGVydGllcyAqL1xuICAgIC8qKiBUaGUgd2lkdGggb2YgdGhlIHZpZXdwb3J0ICovXG4gICAgd2lkdGgsXG4gICAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0ICovXG4gICAgaGVpZ2h0LFxuICAgIC8qKiBUaGUgbGF0aXR1ZGUgYXQgdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgKi9cbiAgICBsYXRpdHVkZSxcbiAgICAvKiogVGhlIGxvbmdpdHVkZSBhdCB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCAqL1xuICAgIGxvbmdpdHVkZSxcbiAgICAvKiogVGhlIHRpbGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLiAqL1xuICAgIHpvb20sXG4gICAgLyoqIFRoZSBiZWFyaW5nIG9mIHRoZSB2aWV3cG9ydCBpbiBkZWdyZWVzICovXG4gICAgYmVhcmluZyA9IERFRkFVTFRfU1RBVEUuYmVhcmluZyxcbiAgICAvKiogVGhlIHBpdGNoIG9mIHRoZSB2aWV3cG9ydCBpbiBkZWdyZWVzICovXG4gICAgcGl0Y2ggPSBERUZBVUxUX1NUQVRFLnBpdGNoLFxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIGFsdGl0dWRlIG9mIHRoZSB2aWV3cG9ydCBjYW1lcmFcbiAgICAgKiBVbml0OiBtYXAgaGVpZ2h0cywgZGVmYXVsdCAxLjVcbiAgICAgKiBOb24tcHVibGljIEFQSSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2lzc3Vlcy8xMTM3XG4gICAgICovXG4gICAgYWx0aXR1ZGUgPSBERUZBVUxUX1NUQVRFLmFsdGl0dWRlLFxuXG4gICAgLyoqIFZpZXdwb3J0IGNvbnN0cmFpbnRzICovXG4gICAgbWF4Wm9vbSA9IE1BUEJPWF9MSU1JVFMubWF4Wm9vbSxcbiAgICBtaW5ab29tID0gTUFQQk9YX0xJTUlUUy5taW5ab29tLFxuICAgIG1heFBpdGNoID0gTUFQQk9YX0xJTUlUUy5tYXhQaXRjaCxcbiAgICBtaW5QaXRjaCA9IE1BUEJPWF9MSU1JVFMubWluUGl0Y2gsXG5cbiAgICAvKiogVHJhbnNpdGlvbiBwcm9wcyAqL1xuICAgIHRyYW5zaXRpb25EdXJhdGlvbixcbiAgICB0cmFuc2l0aW9uRWFzaW5nLFxuICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3IsXG4gICAgdHJhbnNpdGlvbkludGVycnVwdGlvbixcblxuICAgIC8qKiBJbnRlcmFjdGlvbiBzdGF0ZXMsIHJlcXVpcmVkIHRvIGNhbGN1bGF0ZSBjaGFuZ2UgZHVyaW5nIHRyYW5zZm9ybSAqL1xuICAgIC8qIFRoZSBwb2ludCBvbiBtYXAgYmVpbmcgZ3JhYmJlZCB3aGVuIHRoZSBvcGVyYXRpb24gZmlyc3Qgc3RhcnRlZCAqL1xuICAgIHN0YXJ0UGFuTG5nTGF0LFxuICAgIC8qIENlbnRlciBvZiB0aGUgem9vbSB3aGVuIHRoZSBvcGVyYXRpb24gZmlyc3Qgc3RhcnRlZCAqL1xuICAgIHN0YXJ0Wm9vbUxuZ0xhdCxcbiAgICAvKiogQmVhcmluZyB3aGVuIGN1cnJlbnQgcGVyc3BlY3RpdmUgcm90YXRlIG9wZXJhdGlvbiBzdGFydGVkICovXG4gICAgc3RhcnRCZWFyaW5nLFxuICAgIC8qKiBQaXRjaCB3aGVuIGN1cnJlbnQgcGVyc3BlY3RpdmUgcm90YXRlIG9wZXJhdGlvbiBzdGFydGVkICovXG4gICAgc3RhcnRQaXRjaCxcbiAgICAvKiogWm9vbSB3aGVuIGN1cnJlbnQgem9vbSBvcGVyYXRpb24gc3RhcnRlZCAqL1xuICAgIHN0YXJ0Wm9vbVxuICB9ID0ge30pIHtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHdpZHRoKSwgJ2B3aWR0aGAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoaGVpZ2h0KSwgJ2BoZWlnaHRgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxvbmdpdHVkZSksICdgbG9uZ2l0dWRlYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsYXRpdHVkZSksICdgbGF0aXR1ZGVgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHpvb20pLCAnYHpvb21gIG11c3QgYmUgc3VwcGxpZWQnKTtcblxuICAgIHRoaXMuX3ZpZXdwb3J0UHJvcHMgPSB0aGlzLl9hcHBseUNvbnN0cmFpbnRzKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICBsb25naXR1ZGUsXG4gICAgICB6b29tLFxuICAgICAgYmVhcmluZyxcbiAgICAgIHBpdGNoLFxuICAgICAgYWx0aXR1ZGUsXG4gICAgICBtYXhab29tLFxuICAgICAgbWluWm9vbSxcbiAgICAgIG1heFBpdGNoLFxuICAgICAgbWluUGl0Y2gsXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb24sXG4gICAgICB0cmFuc2l0aW9uRWFzaW5nLFxuICAgICAgdHJhbnNpdGlvbkludGVycG9sYXRvcixcbiAgICAgIHRyYW5zaXRpb25JbnRlcnJ1cHRpb25cbiAgICB9KTtcblxuICAgIHRoaXMuX2ludGVyYWN0aXZlU3RhdGUgPSB7XG4gICAgICBzdGFydFBhbkxuZ0xhdCxcbiAgICAgIHN0YXJ0Wm9vbUxuZ0xhdCxcbiAgICAgIHN0YXJ0QmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2gsXG4gICAgICBzdGFydFpvb21cbiAgICB9O1xuICB9XG5cbiAgLyogUHVibGljIEFQSSAqL1xuXG4gIGdldFZpZXdwb3J0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG4gIH1cblxuICBnZXRJbnRlcmFjdGl2ZVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHBhbm5pbmdcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIHBvaW50ZXIgZ3JhYnNcbiAgICovXG4gIHBhblN0YXJ0KHtwb3N9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICBzdGFydFBhbkxuZ0xhdDogdGhpcy5fdW5wcm9qZWN0KHBvcylcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYW5cbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIHBvaW50ZXIgaXNcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdLCBvcHRpb25hbH0gc3RhcnRQb3MgLSB3aGVyZSB0aGUgcG9pbnRlciBncmFiYmVkIGF0XG4gICAqICAgdGhlIHN0YXJ0IG9mIHRoZSBvcGVyYXRpb24uIE11c3QgYmUgc3VwcGxpZWQgb2YgYHBhblN0YXJ0KClgIHdhcyBub3QgY2FsbGVkXG4gICAqL1xuICBwYW4oe3Bvcywgc3RhcnRQb3N9KSB7XG4gICAgY29uc3Qgc3RhcnRQYW5MbmdMYXQgPSB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlLnN0YXJ0UGFuTG5nTGF0IHx8IHRoaXMuX3VucHJvamVjdChzdGFydFBvcyk7XG5cbiAgICBpZiAoIXN0YXJ0UGFuTG5nTGF0KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gPSB0aGlzLl9jYWxjdWxhdGVOZXdMbmdMYXQoe3N0YXJ0UGFuTG5nTGF0LCBwb3N9KTtcblxuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmQgcGFubmluZ1xuICAgKiBNdXN0IGNhbGwgaWYgYHBhblN0YXJ0KClgIHdhcyBjYWxsZWRcbiAgICovXG4gIHBhbkVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgIHN0YXJ0UGFuTG5nTGF0OiBudWxsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcm90YXRpbmdcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIGNlbnRlciBpc1xuICAgKi9cbiAgcm90YXRlU3RhcnQoe3Bvc30pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgIHN0YXJ0QmVhcmluZzogdGhpcy5fdmlld3BvcnRQcm9wcy5iZWFyaW5nLFxuICAgICAgc3RhcnRQaXRjaDogdGhpcy5fdmlld3BvcnRQcm9wcy5waXRjaFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFTY2FsZVggLSBhIG51bWJlciBiZXR3ZWVuIFstMSwgMV0gc3BlY2lmeWluZyB0aGVcbiAgICogICBjaGFuZ2UgdG8gYmVhcmluZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhU2NhbGVZIC0gYSBudW1iZXIgYmV0d2VlbiBbLTEsIDFdIHNwZWNpZnlpbmcgdGhlXG4gICAqICAgY2hhbmdlIHRvIHBpdGNoLiAtMSBzZXRzIHRvIG1pblBpdGNoIGFuZCAxIHNldHMgdG8gbWF4UGl0Y2guXG4gICAqL1xuICByb3RhdGUoe2RlbHRhU2NhbGVYID0gMCwgZGVsdGFTY2FsZVkgPSAwfSkge1xuXG4gICAgY29uc3Qge3N0YXJ0QmVhcmluZywgc3RhcnRQaXRjaH0gPSB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc3RhcnRCZWFyaW5nKSB8fCAhTnVtYmVyLmlzRmluaXRlKHN0YXJ0UGl0Y2gpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCB7cGl0Y2gsIGJlYXJpbmd9ID0gdGhpcy5fY2FsY3VsYXRlTmV3UGl0Y2hBbmRCZWFyaW5nKHtcbiAgICAgIGRlbHRhU2NhbGVYLFxuICAgICAgZGVsdGFTY2FsZVksXG4gICAgICBzdGFydEJlYXJpbmcsXG4gICAgICBzdGFydFBpdGNoXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgIGJlYXJpbmcsXG4gICAgICBwaXRjaFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCByb3RhdGluZ1xuICAgKiBNdXN0IGNhbGwgaWYgYHJvdGF0ZVN0YXJ0KClgIHdhcyBjYWxsZWRcbiAgICovXG4gIHJvdGF0ZUVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE1hcFN0YXRlKHtcbiAgICAgIHN0YXJ0QmVhcmluZzogbnVsbCxcbiAgICAgIHN0YXJ0UGl0Y2g6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB6b29taW5nXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBjZW50ZXIgaXNcbiAgICovXG4gIHpvb21TdGFydCh7cG9zfSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgc3RhcnRab29tTG5nTGF0OiB0aGlzLl91bnByb2plY3QocG9zKSxcbiAgICAgIHN0YXJ0Wm9vbTogdGhpcy5fdmlld3BvcnRQcm9wcy56b29tXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogWm9vbVxuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgY3VycmVudCBjZW50ZXIgaXNcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBzdGFydFBvcyAtIHRoZSBjZW50ZXIgcG9zaXRpb24gYXRcbiAgICogICB0aGUgc3RhcnQgb2YgdGhlIG9wZXJhdGlvbi4gTXVzdCBiZSBzdXBwbGllZCBvZiBgem9vbVN0YXJ0KClgIHdhcyBub3QgY2FsbGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAtIGEgbnVtYmVyIGJldHdlZW4gWzAsIDFdIHNwZWNpZnlpbmcgdGhlIGFjY3VtdWxhdGVkXG4gICAqICAgcmVsYXRpdmUgc2NhbGUuXG4gICAqL1xuICB6b29tKHtwb3MsIHN0YXJ0UG9zLCBzY2FsZX0pIHtcbiAgICBhc3NlcnQoc2NhbGUgPiAwLCAnYHNjYWxlYCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgd2Ugem9vbSBhcm91bmQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb24gcmF0aGVyIHRoYW4gbWFwIGNlbnRlclxuICAgIGxldCB7c3RhcnRab29tLCBzdGFydFpvb21MbmdMYXR9ID0gdGhpcy5faW50ZXJhY3RpdmVTdGF0ZTtcblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHN0YXJ0Wm9vbSkpIHtcbiAgICAgIC8vIFdlIGhhdmUgdHdvIG1vZGVzIG9mIHpvb206XG4gICAgICAvLyBzY3JvbGwgem9vbSB0aGF0IGFyZSBkaXNjcmV0ZSBldmVudHMgKHRyYW5zZm9ybSBmcm9tIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLFxuICAgICAgLy8gYW5kIHBpbmNoIHpvb20gdGhhdCBhcmUgY29udGludW91cyBldmVudHMgKHRyYW5zZm9ybSBmcm9tIHRoZSB6b29tIGxldmVsIHdoZW5cbiAgICAgIC8vIHBpbmNoIHN0YXJ0ZWQpLlxuICAgICAgLy8gSWYgc3RhcnRab29tIHN0YXRlIGlzIGRlZmluZWQsIHRoZW4gdXNlIHRoZSBzdGFydFpvb20gc3RhdGU7XG4gICAgICAvLyBvdGhlcndpc2UgYXNzdW1lIGRpc2NyZXRlIHpvb21pbmdcbiAgICAgIHN0YXJ0Wm9vbSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHMuem9vbTtcbiAgICAgIHN0YXJ0Wm9vbUxuZ0xhdCA9IHRoaXMuX3VucHJvamVjdChzdGFydFBvcykgfHwgdGhpcy5fdW5wcm9qZWN0KHBvcyk7XG4gICAgfVxuXG4gICAgLy8gdGFrZSB0aGUgc3RhcnQgbG5nbGF0IGFuZCBwdXQgaXQgd2hlcmUgdGhlIG1vdXNlIGlzIGRvd24uXG4gICAgYXNzZXJ0KHN0YXJ0Wm9vbUxuZ0xhdCwgJ2BzdGFydFpvb21MbmdMYXRgIHByb3AgaXMgcmVxdWlyZWQgJyArXG4gICAgICAnZm9yIHpvb20gYmVoYXZpb3IgdG8gY2FsY3VsYXRlIHdoZXJlIHRvIHBvc2l0aW9uIHRoZSBtYXAuJyk7XG5cbiAgICBjb25zdCB6b29tID0gdGhpcy5fY2FsY3VsYXRlTmV3Wm9vbSh7c2NhbGUsIHN0YXJ0Wm9vbX0pO1xuXG4gICAgY29uc3Qgem9vbWVkVmlld3BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydChcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3ZpZXdwb3J0UHJvcHMsIHt6b29tfSlcbiAgICApO1xuICAgIGNvbnN0IFtsb25naXR1ZGUsIGxhdGl0dWRlXSA9IHpvb21lZFZpZXdwb3J0LmdldExvY2F0aW9uQXRQb2ludCh7bG5nTGF0OiBzdGFydFpvb21MbmdMYXQsIHBvc30pO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRNYXBTdGF0ZSh7XG4gICAgICB6b29tLFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmQgem9vbWluZ1xuICAgKiBNdXN0IGNhbGwgaWYgYHpvb21TdGFydCgpYCB3YXMgY2FsbGVkXG4gICAqL1xuICB6b29tRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkTWFwU3RhdGUoe1xuICAgICAgc3RhcnRab29tTG5nTGF0OiBudWxsLFxuICAgICAgc3RhcnRab29tOiBudWxsXG4gICAgfSk7XG4gIH1cblxuICAvKiBQcml2YXRlIG1ldGhvZHMgKi9cblxuICBfZ2V0VXBkYXRlZE1hcFN0YXRlKG5ld1Byb3BzKSB7XG4gICAgLy8gVXBkYXRlIF92aWV3cG9ydFByb3BzXG4gICAgcmV0dXJuIG5ldyBNYXBTdGF0ZShPYmplY3QuYXNzaWduKHt9LCB0aGlzLl92aWV3cG9ydFByb3BzLCB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlLCBuZXdQcm9wcykpO1xuICB9XG5cbiAgLy8gQXBwbHkgYW55IGNvbnN0cmFpbnRzIChtYXRoZW1hdGljYWwgb3IgZGVmaW5lZCBieSBfdmlld3BvcnRQcm9wcykgdG8gbWFwIHN0YXRlXG4gIF9hcHBseUNvbnN0cmFpbnRzKHByb3BzKSB7XG4gICAgLy8gRW5zdXJlIHpvb20gaXMgd2l0aGluIHNwZWNpZmllZCByYW5nZVxuICAgIGNvbnN0IHttYXhab29tLCBtaW5ab29tLCB6b29tfSA9IHByb3BzO1xuICAgIHByb3BzLnpvb20gPSBjbGFtcCh6b29tLCBtaW5ab29tLCBtYXhab29tKTtcblxuICAgIC8vIEVuc3VyZSBwaXRjaCBpcyB3aXRoaW4gc3BlY2lmaWVkIHJhbmdlXG4gICAgY29uc3Qge21heFBpdGNoLCBtaW5QaXRjaCwgcGl0Y2h9ID0gcHJvcHM7XG4gICAgcHJvcHMucGl0Y2ggPSBjbGFtcChwaXRjaCwgbWluUGl0Y2gsIG1heFBpdGNoKTtcblxuICAgIE9iamVjdC5hc3NpZ24ocHJvcHMsIG5vcm1hbGl6ZVZpZXdwb3J0UHJvcHMocHJvcHMpKTtcblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIF91bnByb2plY3QocG9zKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh0aGlzLl92aWV3cG9ydFByb3BzKTtcbiAgICByZXR1cm4gcG9zICYmIHZpZXdwb3J0LnVucHJvamVjdChwb3MpO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgbmV3IGxuZ2xhdCBiYXNlZCBvbiBwaXhlbCBkcmFnZ2luZyBwb3NpdGlvblxuICBfY2FsY3VsYXRlTmV3TG5nTGF0KHtzdGFydFBhbkxuZ0xhdCwgcG9zfSkge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodGhpcy5fdmlld3BvcnRQcm9wcyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LmdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb24oe2xuZ0xhdDogc3RhcnRQYW5MbmdMYXQsIHBvc30pO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlcyBuZXcgem9vbVxuICBfY2FsY3VsYXRlTmV3Wm9vbSh7c2NhbGUsIHN0YXJ0Wm9vbX0pIHtcbiAgICBjb25zdCB7bWF4Wm9vbSwgbWluWm9vbX0gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuICAgIGNvbnN0IHpvb20gPSBzdGFydFpvb20gKyBNYXRoLmxvZzIoc2NhbGUpO1xuICAgIHJldHVybiBjbGFtcCh6b29tLCBtaW5ab29tLCBtYXhab29tKTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZXMgYSBuZXcgcGl0Y2ggYW5kIGJlYXJpbmcgZnJvbSBhIHBvc2l0aW9uIChjb21pbmcgZnJvbSBhbiBldmVudClcbiAgX2NhbGN1bGF0ZU5ld1BpdGNoQW5kQmVhcmluZyh7ZGVsdGFTY2FsZVgsIGRlbHRhU2NhbGVZLCBzdGFydEJlYXJpbmcsIHN0YXJ0UGl0Y2h9KSB7XG4gICAgLy8gY2xhbXAgZGVsdGFTY2FsZVkgdG8gWy0xLCAxXSBzbyB0aGF0IHJvdGF0aW9uIGlzIGNvbnN0cmFpbmVkIGJldHdlZW4gbWluUGl0Y2ggYW5kIG1heFBpdGNoLlxuICAgIC8vIGRlbHRhU2NhbGVYIGRvZXMgbm90IG5lZWQgdG8gYmUgY2xhbXBlZCBhcyBiZWFyaW5nIGRvZXMgbm90IGhhdmUgY29uc3RyYWludHMuXG4gICAgZGVsdGFTY2FsZVkgPSBjbGFtcChkZWx0YVNjYWxlWSwgLTEsIDEpO1xuXG4gICAgY29uc3Qge21pblBpdGNoLCBtYXhQaXRjaH0gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuXG4gICAgY29uc3QgYmVhcmluZyA9IHN0YXJ0QmVhcmluZyArIDE4MCAqIGRlbHRhU2NhbGVYO1xuICAgIGxldCBwaXRjaCA9IHN0YXJ0UGl0Y2g7XG4gICAgaWYgKGRlbHRhU2NhbGVZID4gMCkge1xuICAgICAgLy8gR3JhZHVhbGx5IGluY3JlYXNlIHBpdGNoXG4gICAgICBwaXRjaCA9IHN0YXJ0UGl0Y2ggKyBkZWx0YVNjYWxlWSAqIChtYXhQaXRjaCAtIHN0YXJ0UGl0Y2gpO1xuICAgIH0gZWxzZSBpZiAoZGVsdGFTY2FsZVkgPCAwKSB7XG4gICAgICAvLyBHcmFkdWFsbHkgZGVjcmVhc2UgcGl0Y2hcbiAgICAgIHBpdGNoID0gc3RhcnRQaXRjaCAtIGRlbHRhU2NhbGVZICogKG1pblBpdGNoIC0gc3RhcnRQaXRjaCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBpdGNoLFxuICAgICAgYmVhcmluZ1xuICAgIH07XG4gIH1cblxufVxuIl19